{"version":3,"sources":["index.js","const-enum.js","enum.js","namespace.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxTypescript = require(\"@babel/plugin-syntax-typescript\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\n\nvar _constEnum = require(\"./const-enum\");\n\nvar _enum = require(\"./enum\");\n\nvar _namespace = require(\"./namespace\");\n\nfunction isInType(path) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case \"TSQualifiedName\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n\n    case \"ExportSpecifier\":\n      return path.parentPath.parent.exportKind === \"type\";\n\n    default:\n      return false;\n  }\n}\n\nconst GLOBAL_TYPES = new WeakMap();\nconst NEEDS_EXPLICIT_ESM = new WeakMap();\nconst PARSED_PARAMS = new WeakSet();\n\nfunction isGlobalType(path, name) {\n  const program = path.find(path => path.isProgram()).node;\n  if (path.scope.hasOwnBinding(name)) return false;\n  if (GLOBAL_TYPES.get(program).has(name)) return true;\n  console.warn(`The exported identifier \"${name}\" is not declared in Babel's scope tracker\\n` + `as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\\n` + `never encountered it as a TypeScript type declaration.\\n` + `It will be treated as a JavaScript value.\\n\\n` + `This problem is likely caused by another plugin injecting\\n` + `\"${name}\" without registering it in the scope tracker. If you are the author\\n` + ` of that plugin, please use \"scope.registerDeclaration(declarationPath)\".`);\n  return false;\n}\n\nfunction registerGlobalType(programNode, name) {\n  GLOBAL_TYPES.get(programNode).add(name);\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const JSX_PRAGMA_REGEX = /\\*?\\s*@jsx((?:Frag)?)\\s+([^\\s]+)/;\n  const {\n    allowNamespaces = true,\n    jsxPragma = \"React.createElement\",\n    jsxPragmaFrag = \"React.Fragment\",\n    onlyRemoveTypeImports = false,\n    optimizeConstEnums = false\n  } = opts;\n  {\n    var {\n      allowDeclareFields = false\n    } = opts;\n  }\n  const classMemberVisitors = {\n    field(path) {\n      const {\n        node\n      } = path;\n      {\n        if (!allowDeclareFields && node.declare) {\n          throw path.buildCodeFrameError(`The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` + `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`);\n        }\n      }\n\n      if (node.declare) {\n        if (node.value) {\n          throw path.buildCodeFrameError(`Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`);\n        }\n\n        if (!node.decorators) {\n          path.remove();\n        }\n      } else if (node.definite) {\n        if (node.value) {\n          throw path.buildCodeFrameError(`Definitely assigned fields cannot be initialized here, but only in the constructor`);\n        }\n\n        {\n          if (!allowDeclareFields && !node.decorators) {\n            path.remove();\n          }\n        }\n      } else {\n        if (!allowDeclareFields && !node.value && !node.decorators && !_core.types.isClassPrivateProperty(node)) {\n          path.remove();\n        }\n      }\n\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.readonly) node.readonly = null;\n      if (node.optional) node.optional = null;\n      if (node.typeAnnotation) node.typeAnnotation = null;\n      if (node.definite) node.definite = null;\n      if (node.declare) node.declare = null;\n      if (node.override) node.override = null;\n    },\n\n    method({\n      node\n    }) {\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.optional) node.optional = null;\n      if (node.override) node.override = null;\n    },\n\n    constructor(path, classPath) {\n      if (path.node.accessibility) path.node.accessibility = null;\n      const parameterProperties = [];\n\n      for (const param of path.node.params) {\n        if (param.type === \"TSParameterProperty\" && !PARSED_PARAMS.has(param.parameter)) {\n          PARSED_PARAMS.add(param.parameter);\n          parameterProperties.push(param.parameter);\n        }\n      }\n\n      if (parameterProperties.length) {\n        const assigns = parameterProperties.map(p => {\n          let id;\n\n          if (_core.types.isIdentifier(p)) {\n            id = p;\n          } else if (_core.types.isAssignmentPattern(p) && _core.types.isIdentifier(p.left)) {\n            id = p.left;\n          } else {\n            throw path.buildCodeFrameError(\"Parameter properties can not be destructuring patterns.\");\n          }\n\n          return _core.template.statement.ast`\n              this.${_core.types.cloneNode(id)} = ${_core.types.cloneNode(id)}`;\n        });\n        (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);\n      }\n    }\n\n  };\n  return {\n    name: \"transform-typescript\",\n    inherits: _pluginSyntaxTypescript.default,\n    visitor: {\n      Pattern: visitPattern,\n      Identifier: visitPattern,\n      RestElement: visitPattern,\n      Program: {\n        enter(path, state) {\n          const {\n            file\n          } = state;\n          let fileJsxPragma = null;\n          let fileJsxPragmaFrag = null;\n          const programNode = path.node;\n\n          if (!GLOBAL_TYPES.has(programNode)) {\n            GLOBAL_TYPES.set(programNode, new Set());\n          }\n\n          if (file.ast.comments) {\n            for (const comment of file.ast.comments) {\n              const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);\n\n              if (jsxMatches) {\n                if (jsxMatches[1]) {\n                  fileJsxPragmaFrag = jsxMatches[2];\n                } else {\n                  fileJsxPragma = jsxMatches[2];\n                }\n              }\n            }\n          }\n\n          let pragmaImportName = fileJsxPragma || jsxPragma;\n\n          if (pragmaImportName) {\n            [pragmaImportName] = pragmaImportName.split(\".\");\n          }\n\n          let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;\n\n          if (pragmaFragImportName) {\n            [pragmaFragImportName] = pragmaFragImportName.split(\".\");\n          }\n\n          for (let stmt of path.get(\"body\")) {\n            if (stmt.isImportDeclaration()) {\n              if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n              }\n\n              if (stmt.node.importKind === \"type\") {\n                for (const specifier of stmt.node.specifiers) {\n                  registerGlobalType(programNode, specifier.local.name);\n                }\n\n                stmt.remove();\n                continue;\n              }\n\n              const importsToRemove = new Set();\n              const specifiersLength = stmt.node.specifiers.length;\n\n              const isAllSpecifiersElided = () => specifiersLength > 0 && specifiersLength === importsToRemove.size;\n\n              for (const specifier of stmt.node.specifiers) {\n                if (specifier.type === \"ImportSpecifier\" && specifier.importKind === \"type\") {\n                  registerGlobalType(programNode, specifier.local.name);\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n\n                  if (binding) {\n                    importsToRemove.add(binding.path);\n                  }\n                }\n              }\n\n              if (onlyRemoveTypeImports) {\n                NEEDS_EXPLICIT_ESM.set(path.node, false);\n              } else {\n                if (stmt.node.specifiers.length === 0) {\n                  NEEDS_EXPLICIT_ESM.set(path.node, false);\n                  continue;\n                }\n\n                for (const specifier of stmt.node.specifiers) {\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n\n                  if (binding && !importsToRemove.has(binding.path)) {\n                    if (isImportTypeOnly({\n                      binding,\n                      programPath: path,\n                      pragmaImportName,\n                      pragmaFragImportName\n                    })) {\n                      importsToRemove.add(binding.path);\n                    } else {\n                      NEEDS_EXPLICIT_ESM.set(path.node, false);\n                    }\n                  }\n                }\n              }\n\n              if (isAllSpecifiersElided()) {\n                stmt.remove();\n              } else {\n                for (const importPath of importsToRemove) {\n                  importPath.remove();\n                }\n              }\n\n              continue;\n            }\n\n            if (stmt.isExportDeclaration()) {\n              stmt = stmt.get(\"declaration\");\n            }\n\n            if (stmt.isVariableDeclaration({\n              declare: true\n            })) {\n              for (const name of Object.keys(stmt.getBindingIdentifiers())) {\n                registerGlobalType(programNode, name);\n              }\n            } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get(\"id\").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({\n              declare: true\n            }) || stmt.isTSEnumDeclaration({\n              declare: true\n            }) || stmt.isTSModuleDeclaration({\n              declare: true\n            }) && stmt.get(\"id\").isIdentifier()) {\n              registerGlobalType(programNode, stmt.node.id.name);\n            }\n          }\n        },\n\n        exit(path) {\n          if (path.node.sourceType === \"module\" && NEEDS_EXPLICIT_ESM.get(path.node)) {\n            path.pushContainer(\"body\", _core.types.exportNamedDeclaration());\n          }\n        }\n\n      },\n\n      ExportNamedDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n\n        if (path.node.exportKind === \"type\") {\n          path.remove();\n          return;\n        }\n\n        if (path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(specifier => specifier.type === \"ExportSpecifier\" && specifier.exportKind === \"type\")) {\n          path.remove();\n          return;\n        }\n\n        if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(specifier => _core.types.isExportSpecifier(specifier) && isGlobalType(path, specifier.local.name))) {\n          path.remove();\n          return;\n        }\n\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n\n      ExportSpecifier(path) {\n        const parent = path.parent;\n\n        if (!parent.source && isGlobalType(path, path.node.local.name) || path.node.exportKind === \"type\") {\n          path.remove();\n        }\n      },\n\n      ExportDefaultDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n\n        if (_core.types.isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {\n          path.remove();\n          return;\n        }\n\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n\n      TSDeclareFunction(path) {\n        path.remove();\n      },\n\n      TSDeclareMethod(path) {\n        path.remove();\n      },\n\n      VariableDeclaration(path) {\n        if (path.node.declare) {\n          path.remove();\n        }\n      },\n\n      VariableDeclarator({\n        node\n      }) {\n        if (node.definite) node.definite = null;\n      },\n\n      TSIndexSignature(path) {\n        path.remove();\n      },\n\n      ClassDeclaration(path) {\n        const {\n          node\n        } = path;\n\n        if (node.declare) {\n          path.remove();\n          return;\n        }\n      },\n\n      Class(path) {\n        const {\n          node\n        } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.superTypeParameters) node.superTypeParameters = null;\n        if (node.implements) node.implements = null;\n        if (node.abstract) node.abstract = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassMethod() || child.isClassPrivateMethod()) {\n            if (child.node.kind === \"constructor\") {\n              classMemberVisitors.constructor(child, path);\n            } else {\n              classMemberVisitors.method(child);\n            }\n          } else if (child.isClassProperty() || child.isClassPrivateProperty()) {\n            classMemberVisitors.field(child);\n          }\n        });\n      },\n\n      Function(path) {\n        const {\n          node,\n          scope\n        } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.returnType) node.returnType = null;\n        const params = node.params;\n\n        if (params.length > 0 && _core.types.isIdentifier(params[0], {\n          name: \"this\"\n        })) {\n          params.shift();\n        }\n\n        const paramsPath = path.get(\"params\");\n\n        for (const p of paramsPath) {\n          if (p.type === \"TSParameterProperty\") {\n            p.replaceWith(p.get(\"parameter\"));\n            scope.registerBinding(\"param\", p);\n          }\n        }\n      },\n\n      TSModuleDeclaration(path) {\n        (0, _namespace.default)(path, _core.types, allowNamespaces);\n      },\n\n      TSInterfaceDeclaration(path) {\n        path.remove();\n      },\n\n      TSTypeAliasDeclaration(path) {\n        path.remove();\n      },\n\n      TSEnumDeclaration(path) {\n        if (optimizeConstEnums && path.node.const) {\n          (0, _constEnum.default)(path, _core.types);\n        } else {\n          (0, _enum.default)(path, _core.types);\n        }\n      },\n\n      TSImportEqualsDeclaration(path) {\n        if (_core.types.isTSExternalModuleReference(path.node.moduleReference)) {\n          throw path.buildCodeFrameError(`\\`import ${path.node.id.name} = require('${path.node.moduleReference.expression.value}')\\` ` + \"is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using \" + `\\`import ${path.node.id.name} from '${path.node.moduleReference.expression.value}';\\` alongside ` + \"Typescript's --allowSyntheticDefaultImports option.\");\n        }\n\n        path.replaceWith(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(path.node.id, entityNameToExpr(path.node.moduleReference))]));\n      },\n\n      TSExportAssignment(path) {\n        throw path.buildCodeFrameError(\"`export =` is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using `export <value>;`.\");\n      },\n\n      TSTypeAssertion(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      TSAsExpression(path) {\n        let {\n          node\n        } = path;\n\n        do {\n          node = node.expression;\n        } while (_core.types.isTSAsExpression(node));\n\n        path.replaceWith(node);\n      },\n\n      TSNonNullExpression(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      CallExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      OptionalCallExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      NewExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      JSXOpeningElement(path) {\n        path.node.typeParameters = null;\n      },\n\n      TaggedTemplateExpression(path) {\n        path.node.typeParameters = null;\n      }\n\n    }\n  };\n\n  function entityNameToExpr(node) {\n    if (_core.types.isTSQualifiedName(node)) {\n      return _core.types.memberExpression(entityNameToExpr(node.left), node.right);\n    }\n\n    return node;\n  }\n\n  function visitPattern({\n    node\n  }) {\n    if (node.typeAnnotation) node.typeAnnotation = null;\n    if (_core.types.isIdentifier(node) && node.optional) node.optional = null;\n  }\n\n  function isImportTypeOnly({\n    binding,\n    programPath,\n    pragmaImportName,\n    pragmaFragImportName\n  }) {\n    for (const path of binding.referencePaths) {\n      if (!isInType(path)) {\n        return false;\n      }\n    }\n\n    if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {\n      return true;\n    }\n\n    let sourceFileHasJsx = false;\n    programPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        sourceFileHasJsx = true;\n        path.stop();\n      }\n\n    });\n    return !sourceFileHasJsx;\n  }\n});\n\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileConstEnum;\n\nvar _enum = require(\"./enum\");\n\nfunction transpileConstEnum(path, t) {\n  const {\n    name\n  } = path.node.id;\n  const parentIsExport = path.parentPath.isExportNamedDeclaration();\n  let isExported = parentIsExport;\n\n  if (!isExported && t.isProgram(path.parent)) {\n    isExported = path.parent.body.some(stmt => t.isExportNamedDeclaration(stmt) && !stmt.source && stmt.specifiers.some(spec => t.isExportSpecifier(spec) && spec.local.name === name));\n  }\n\n  const entries = (0, _enum.translateEnumValues)(path, t);\n\n  if (isExported) {\n    const obj = t.objectExpression(entries.map(([name, value]) => t.objectProperty(t.isValidIdentifier(name) ? t.identifier(name) : t.stringLiteral(name), value)));\n\n    if (path.scope.hasOwnBinding(name)) {\n      (parentIsExport ? path.parentPath : path).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")), [path.node.id, obj])));\n    } else {\n      path.replaceWith(t.variableDeclaration(\"var\", [t.variableDeclarator(path.node.id, obj)]));\n      path.scope.registerDeclaration(path);\n    }\n\n    return;\n  }\n\n  const entriesMap = new Map(entries);\n  path.scope.path.traverse({\n    Scope(path) {\n      if (path.scope.hasOwnBinding(name)) path.skip();\n    },\n\n    MemberExpression(path) {\n      if (!t.isIdentifier(path.node.object, {\n        name\n      })) return;\n      let key;\n\n      if (path.node.computed) {\n        if (t.isStringLiteral(path.node.property)) {\n          key = path.node.property.value;\n        } else {\n          return;\n        }\n      } else if (t.isIdentifier(path.node.property)) {\n        key = path.node.property.name;\n      } else {\n        return;\n      }\n\n      if (!entriesMap.has(key)) return;\n      path.replaceWith(t.cloneNode(entriesMap.get(key)));\n    }\n\n  });\n  path.remove();\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileEnum;\nexports.translateEnumValues = translateEnumValues;\n\nvar _core = require(\"@babel/core\");\n\nvar _assert = require(\"assert\");\n\nfunction transpileEnum(path, t) {\n  const {\n    node\n  } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const fill = enumFill(path, t, node.id);\n\n  switch (path.parent.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\":\n      {\n        path.insertAfter(fill);\n\n        if (seen(path.parentPath)) {\n          path.remove();\n        } else {\n          const isGlobal = t.isProgram(path.parent);\n          path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? \"var\" : \"let\"))[0]);\n        }\n\n        break;\n      }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath) {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nfunction makeVar(id, t, kind) {\n  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);\n}\n\nconst buildEnumWrapper = (0, _core.template)(`\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n`);\nconst buildStringAssignment = (0, _core.template)(`\n  ENUM[\"NAME\"] = VALUE;\n`);\nconst buildNumericAssignment = (0, _core.template)(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\nfunction enumFill(path, t, id) {\n  const x = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) => buildEnumMember(t.isStringLiteral(memberValue), {\n    ENUM: t.cloneNode(id),\n    NAME: memberName,\n    VALUE: memberValue\n  }));\n  return buildEnumWrapper({\n    ID: t.cloneNode(id),\n    ASSIGNMENTS: assignments\n  });\n}\n\nfunction ReferencedIdentifier(expr, state) {\n  const {\n    seen,\n    path,\n    t\n  } = state;\n  const name = expr.node.name;\n\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)));\n    expr.skip();\n  }\n}\n\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier\n};\n\nfunction translateEnumValues(path, t) {\n  const seen = new Map();\n  let constValue = -1;\n  let lastName;\n  return path.get(\"members\").map(memberPath => {\n    const member = memberPath.node;\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializer = member.initializer;\n    let value;\n\n    if (initializer) {\n      constValue = evaluate(initializer, seen);\n\n      if (constValue !== undefined) {\n        seen.set(name, constValue);\n\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n        } else {\n          _assert(typeof constValue === \"string\");\n\n          value = t.stringLiteral(constValue);\n        }\n      } else {\n        const initializerPath = memberPath.get(\"initializer\");\n\n        if (initializerPath.isReferencedIdentifier()) {\n          ReferencedIdentifier(initializerPath, {\n            t,\n            seen,\n            path\n          });\n        } else {\n          initializerPath.traverse(enumSelfReferenceVisitor, {\n            t,\n            seen,\n            path\n          });\n        }\n\n        value = initializerPath.node;\n        seen.set(name, undefined);\n      }\n    } else if (typeof constValue === \"number\") {\n      constValue += 1;\n      value = t.numericLiteral(constValue);\n      seen.set(name, constValue);\n    } else if (typeof constValue === \"string\") {\n      throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n    } else {\n      const lastRef = t.memberExpression(t.cloneNode(path.node.id), t.stringLiteral(lastName), true);\n      value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n      seen.set(name, undefined);\n    }\n\n    lastName = name;\n    return [name, value];\n  });\n}\n\nfunction evaluate(expr, seen) {\n  return evalConstant(expr);\n\n  function evalConstant(expr) {\n    switch (expr.type) {\n      case \"StringLiteral\":\n        return expr.value;\n\n      case \"UnaryExpression\":\n        return evalUnaryExpression(expr);\n\n      case \"BinaryExpression\":\n        return evalBinaryExpression(expr);\n\n      case \"NumericLiteral\":\n        return expr.value;\n\n      case \"ParenthesizedExpression\":\n        return evalConstant(expr.expression);\n\n      case \"Identifier\":\n        return seen.get(expr.name);\n\n      case \"TemplateLiteral\":\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalUnaryExpression({\n    argument,\n    operator\n  }) {\n    const value = evalConstant(argument);\n\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (operator) {\n      case \"+\":\n        return value;\n\n      case \"-\":\n        return -value;\n\n      case \"~\":\n        return ~value;\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(expr) {\n    const left = evalConstant(expr.left);\n\n    if (left === undefined) {\n      return undefined;\n    }\n\n    const right = evalConstant(expr.right);\n\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (expr.operator) {\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n\n      case \"<<\":\n        return left << right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"*\":\n        return left * right;\n\n      case \"/\":\n        return left / right;\n\n      case \"+\":\n        return left + right;\n\n      case \"-\":\n        return left - right;\n\n      case \"%\":\n        return left % right;\n\n      default:\n        return undefined;\n    }\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileNamespace;\n\nvar _core = require(\"@babel/core\");\n\nfunction transpileNamespace(path, t, allowNamespaces) {\n  if (path.node.declare || path.node.id.type === \"StringLiteral\") {\n    path.remove();\n    return;\n  }\n\n  if (!allowNamespaces) {\n    throw path.hub.file.buildCodeFrameError(path.node.id, \"Namespace not marked type-only declare.\" + \" Non-declarative namespaces are only supported experimentally in Babel.\" + \" To enable and review caveats see:\" + \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\");\n  }\n\n  const name = path.node.id.name;\n  const value = handleNested(path, t, t.cloneDeep(path.node));\n  const bound = path.scope.hasOwnBinding(name);\n\n  if (path.parent.type === \"ExportNamedDeclaration\") {\n    if (!bound) {\n      path.parentPath.insertAfter(value);\n      path.replaceWith(getDeclaration(t, name));\n      path.scope.registerDeclaration(path.parentPath);\n    } else {\n      path.parentPath.replaceWith(value);\n    }\n  } else if (bound) {\n    path.replaceWith(value);\n  } else {\n    path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t, name), value])[0]);\n  }\n}\n\nfunction getDeclaration(t, name) {\n  return t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(name))]);\n}\n\nfunction getMemberExpression(t, name, itemName) {\n  return t.memberExpression(t.identifier(name), t.identifier(itemName));\n}\n\nfunction handleVariableDeclaration(node, name, hub) {\n  if (node.kind !== \"const\") {\n    throw hub.file.buildCodeFrameError(node, \"Namespaces exporting non-const are not supported by Babel.\" + \" Change to const or see:\" + \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\");\n  }\n\n  const {\n    declarations\n  } = node;\n\n  if (declarations.every(declarator => _core.types.isIdentifier(declarator.id))) {\n    for (const declarator of declarations) {\n      declarator.init = _core.types.assignmentExpression(\"=\", getMemberExpression(_core.types, name, declarator.id.name), declarator.init);\n    }\n\n    return [node];\n  }\n\n  const bindingIdentifiers = _core.types.getBindingIdentifiers(node);\n\n  const assignments = [];\n\n  for (const idName in bindingIdentifiers) {\n    assignments.push(_core.types.assignmentExpression(\"=\", getMemberExpression(_core.types, name, idName), _core.types.cloneNode(bindingIdentifiers[idName])));\n  }\n\n  return [node, _core.types.expressionStatement(_core.types.sequenceExpression(assignments))];\n}\n\nfunction buildNestedAmbiendModuleError(path, node) {\n  throw path.hub.buildError(node, \"Ambient modules cannot be nested in other modules or namespaces.\", Error);\n}\n\nfunction handleNested(path, t, node, parentExport) {\n  const names = new Set();\n  const realName = node.id;\n  t.assertIdentifier(realName);\n  const name = path.scope.generateUid(realName.name);\n  const namespaceTopLevel = t.isTSModuleBlock(node.body) ? node.body.body : [t.exportNamedDeclaration(node.body)];\n\n  for (let i = 0; i < namespaceTopLevel.length; i++) {\n    const subNode = namespaceTopLevel[i];\n\n    switch (subNode.type) {\n      case \"TSModuleDeclaration\":\n        {\n          if (!t.isIdentifier(subNode.id)) {\n            throw buildNestedAmbiendModuleError(path, subNode);\n          }\n\n          const transformed = handleNested(path, t, subNode);\n          const moduleName = subNode.id.name;\n\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);\n          }\n\n          continue;\n        }\n\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        names.add(subNode.id.name);\n        continue;\n\n      case \"VariableDeclaration\":\n        {\n          for (const name in t.getBindingIdentifiers(subNode)) {\n            names.add(name);\n          }\n\n          continue;\n        }\n\n      default:\n        continue;\n\n      case \"ExportNamedDeclaration\":\n    }\n\n    switch (subNode.declaration.type) {\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        {\n          const itemName = subNode.declaration.id.name;\n          names.add(itemName);\n          namespaceTopLevel.splice(i++, 1, subNode.declaration, t.expressionStatement(t.assignmentExpression(\"=\", getMemberExpression(t, name, itemName), t.identifier(itemName))));\n          break;\n        }\n\n      case \"VariableDeclaration\":\n        {\n          const nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);\n          namespaceTopLevel.splice(i, nodes.length, ...nodes);\n          i += nodes.length - 1;\n          break;\n        }\n\n      case \"TSModuleDeclaration\":\n        {\n          if (!t.isIdentifier(subNode.declaration.id)) {\n            throw buildNestedAmbiendModuleError(path, subNode.declaration);\n          }\n\n          const transformed = handleNested(path, t, subNode.declaration, t.identifier(name));\n          const moduleName = subNode.declaration.id.name;\n\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);\n          }\n        }\n    }\n  }\n\n  let fallthroughValue = t.objectExpression([]);\n\n  if (parentExport) {\n    const memberExpr = t.memberExpression(parentExport, realName);\n    fallthroughValue = _core.template.expression.ast`\n      ${t.cloneNode(memberExpr)} ||\n        (${t.cloneNode(memberExpr)} = ${fallthroughValue})\n    `;\n  }\n\n  return _core.template.statement.ast`\n    (function (${t.identifier(name)}) {\n      ${namespaceTopLevel}\n    })(${realName} || (${t.cloneNode(realName)} = ${fallthroughValue}));\n  `;\n}"]}