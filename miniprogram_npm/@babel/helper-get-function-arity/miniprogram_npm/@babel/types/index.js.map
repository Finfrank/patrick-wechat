{"version":3,"sources":["index.js","validators/react/isReactComponent.js","validators/buildMatchMemberExpression.js","validators/matchesPattern.js","validators/generated/index.js","validators/is.js","utils/shallowEqual.js","validators/isType.js","definitions/index.js","definitions/core.js","validators/isValidIdentifier.js","constants/index.js","definitions/utils.js","definitions/es2015.js","definitions/flow.js","definitions/jsx.js","definitions/misc.js","definitions/experimental.js","definitions/typescript.js","validators/react/isCompatTag.js","builders/react/buildChildren.js","utils/react/cleanJSXElementLiteralChild.js","builders/generated/index.js","builders/builder.js","validators/validate.js","asserts/assertNode.js","validators/isNode.js","asserts/generated/index.js","builders/flow/createTypeAnnotationBasedOnTypeof.js","builders/flow/createUnionTypeAnnotation.js","modifications/flow/removeTypeDuplicates.js","clone/cloneNode.js","clone/clone.js","clone/cloneDeep.js","clone/cloneWithoutLoc.js","comments/addComment.js","comments/addComments.js","comments/inheritInnerComments.js","utils/inherit.js","comments/inheritLeadingComments.js","comments/inheritsComments.js","comments/inheritTrailingComments.js","comments/removeComments.js","constants/generated/index.js","converters/ensureBlock.js","converters/toBlock.js","converters/toBindingIdentifierName.js","converters/toIdentifier.js","converters/toComputedKey.js","converters/toExpression.js","converters/toKeyAlias.js","modifications/removePropertiesDeep.js","traverse/traverseFast.js","modifications/removeProperties.js","converters/toSequenceExpression.js","converters/gatherSequenceExpressions.js","retrievers/getBindingIdentifiers.js","converters/toStatement.js","converters/valueToNode.js","modifications/appendToMemberExpression.js","modifications/inherits.js","modifications/prependToMemberExpression.js","retrievers/getOuterBindingIdentifiers.js","traverse/traverse.js","validators/isBinding.js","validators/isBlockScoped.js","validators/isLet.js","validators/isImmutable.js","validators/isNodesEquivalent.js","validators/isReferenced.js","validators/isScope.js","validators/isSpecifierDefault.js","validators/isValidES3Identifier.js","validators/isVar.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ACHA,AFMA,AFMA;ADIA,AENA,AENA,ACHA,AFMA,AFMA;ADIA,AENA,AENA,ACHA,AFMA;AHUA,AMlBA,AJYA,AENA,ACHA,AFMA;AHUA,AMlBA,AJYA,AENA,ACHA,AFMA;AHUA,AMlBA,AJYA,AENA,ACHA,AFMA;AHUA,AMlBA,AJYA,AENA,ACHA,AENA,AJYA;AHUA,AMlBA,AJYA,AENA,ACHA,AENA,AJYA;AHUA,AMlBA,AFMA,ACHA,AENA,AJYA;AKdA,ARwBA,AMlBA,AFMA,ACHA,AENA,AJYA;AKdA,ARwBA,AMlBA,AFMA,ACHA,AENA,AJYA;AKdA,ARwBA,AMlBA,AFMA,ACHA,AENA,AJYA;AMjBA,ADGA,ARwBA,AMlBA,AFMA,ACHA,AENA,AJYA;AMjBA,ADGA,ARwBA,AMlBA,AFMA,ACHA,AENA,AJYA;AMjBA,ADGA,ARwBA,AMlBA,AFMA,ACHA,AENA,AJYA;AMjBA,ADGA,ARwBA,AMlBA,AFMA,ACHA,AENA,AGTA,APqBA;AMjBA,ADGA,ARwBA,AMlBA,AFMA,ACHA,AENA,AGTA,APqBA;AMjBA,ADGA,ARwBA,AMlBA,AFMA,ACHA,AENA,AGTA,APqBA;AQvBA,AFMA,ADGA,ARwBA,AMlBA,AFMA,ACHA,AENA,AGTA,APqBA;AQvBA,AFMA,ADGA,ARwBA,AMlBA,AFMA,ACHA,AENA,AGTA,APqBA;AQvBA,AFMA,ADGA,ARwBA,AMlBA,AFMA,ACHA,AENA,AGTA,APqBA;AQvBA,AFMA,ADGA,AIZA,AZoCA,AMlBA,AFMA,ACHA,AENA,AGTA,APqBA;AQvBA,AFMA,ADGA,AIZA,AZoCA,AMlBA,AFMA,ACHA,AENA,AGTA,APqBA;AQvBA,AFMA,ADGA,AIZA,AZoCA,AMlBA,AFMA,ACHA,AENA,AGTA,APqBA;AQvBA,AFMA,AIZA,ALeA,AIZA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ALeA,AIZA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ALeA,AIZA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ACHA,ANkBA,AIZA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ACHA,ANkBA,AIZA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ACHA,ANkBA,AIZA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ACHA,ANkBA,AOrBA,AHSA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ACHA,ANkBA,AOrBA,AHSA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ACHA,ANkBA,AOrBA,AHSA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ACHA,ANkBA,AOrBA,ACHA,AJYA,AZoCA,AIZA,AGTA,AGTA,APqBA;AQvBA,AFMA,AIZA,ACHA,ANkBA,AOrBA,ACHA,AJYA,AZoCA,AIZA,AGTA,AGTA;ACFA,AFMA,AIZA,ACHA,ANkBA,AOrBA,ACHA,AJYA,AZoCA,AIZA,AGTA,AGTA;ACFA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AJYA,AZoCA,AIZA,AGTA,AGTA;ACFA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AJYA,AZoCA,AIZA,AGTA,AGTA;ACFA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AJYA,AZoCA,AIZA,AGTA,AGTA;ACFA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AIZA,AGTA,AGTA;ACFA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AIZA,AGTA,AGTA;ACFA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AIZA,AGTA,AGTA;ACFA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AIZA,AMlBA,AS3BA;ARyBA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AIZA,Ae7CA;ARyBA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AIZA,Ae7CA;ACFA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AIZA,Ae7CA;ACFA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AIZA,Ae7CA;ACFA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AIZA,Ae7CA;ACFA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AqB/DA,AjBmDA,Ae7CA;ACFA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AqB/DA,AjBmDA,Ae7CA;ACFA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,ACHA,AENA,ANkBA,AZoCA,AqB/DA,AjBmDA,Ae7CA;AGRA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,Ae7CA;AGRA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA;AkBrDA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA;AmBxDA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA;AmBxDA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA;AmBxDA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA;AmBxDA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AoB5DA;ADIA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AoB5DA;ADIA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AoB5DA;ACFA,AFMA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AoB5DA;ACFA,AFMA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AoB5DA;ACFA,AFMA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AoB5DA;ACFA,AFMA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AFMA,ADGA,AFMA,AT2BA,AFMA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AFMA,ADGA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,ADGA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,ADGA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,ADGA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,AKfA,ANkBA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,AKfA,ANkBA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,AKfA,ANkBA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,AKfA,ACHA,APqBA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,AKfA,ACHA,APqBA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,AKfA,ACHA,APqBA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,AqB/DA,AjBmDA,AsBlEA,AFMA;ACFA,AENA,AJYA,AKfA,ACHA,APqBA,AFMA,AXiCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AqB9DA,AENA,AJYA,AKfA,ACHA,APqBA,AbuCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AbuCA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AS3BA,AtBkEA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AS3BA,AtBkEA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AS3BA,AtBkEA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ADGA,AtBkEA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ADGA,AtBkEA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ADGA,AtBkEA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AtBkEA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AtBkEA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AtBkEA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AGTA,AzB2EA,AIZA,AIZA,AHSA,ANkBA,AOrBA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AGTA,AzB2EA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AGTA,AzB2EA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AGTA,ACHA,A1B8EA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AGTA,ACHA,A1B8EA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AGTA,ACHA,A1B8EA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ACHA,APqBA,AU9BA,ACHA,AFMA,AGTA,ACHA,ACHA,A3BiFA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ANkBA,AU9BA,ACHA,AFMA,AGTA,ACHA,ACHA,A3BiFA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AT2BA,AjBmDA;AuBpEA,AJYA,AKfA,ANkBA,AWjCA,AFMA,AGTA,ACHA,ACHA,A3BiFA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,AJYA,AKfA,ANkBA,AWjCA,AFMA,AGTA,ACHA,ACHA,ACHA,A5BoFA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,AJYA,ADGA,AWjCA,AFMA,AGTA,ACHA,ACHA,ACHA,A5BoFA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,AJYA,ADGA,AS3BA,AGTA,ACHA,ACHA,ACHA,A5BoFA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,AJYA,ADGA,AS3BA,AGTA,ACHA,ACHA,ACHA,A5BoFA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,AJYA,ADGA,AS3BA,AGTA,ACHA,ACHA,ACHA,A5BoFA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,AJYA,ADGA,AS3BA,AGTA,ACHA,ACHA,ACHA,A5BoFA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,AJYA,ADGA,AS3BA,AGTA,ACHA,ACHA,ACHA,AENA,A9B0FA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,AJYA,ADGA,AS3BA,AIZA,ACHA,ACHA,AENA,A9B0FA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,AJYA,ADGA,AS3BA,AIZA,ACHA,ACHA,AENA,A9B0FA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,AJYA,ADGA,AS3BA,AIZA,ACHA,ACHA,AENA,ACHA,A/B6FA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,AJYA,ADGA,AS3BA,AIZA,ACHA,ACHA,AENA,ACHA,A/B6FA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,AJYA,ADGA,AS3BA,AKfA,ACHA,AENA,ACHA,A/B6FA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AKfA,ACHA,AENA,AENA,ADGA,A/B6FA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AKfA,ACHA,AENA,AENA,ADGA,A/B6FA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AKfA,AGTA,AENA,ADGA,A/B6FA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AKfA,AGTA,AENA,ADGA,AENA,AjCmGA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AKfA,AGTA,AENA,ADGA,AENA,AjCmGA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AKfA,AGTA,AENA,ADGA,AENA,AjCmGA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AKfA,AGTA,AENA,ADGA,AENA,ACHA,AlCsGA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AKfA,AGTA,AENA,ADGA,AENA,ACHA,AlCsGA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AU9BA,ADGA,AENA,ACHA,AlCsGA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AU9BA,ADGA,AENA,ACHA,ACHA,AnCyGA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AU9BA,ADGA,AENA,ACHA,ACHA,AnCyGA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AU9BA,ADGA,AENA,ACHA,ACHA,AnCyGA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AU9BA,ADGA,AENA,ACHA,ACHA,ACHA,ApC4GA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AU9BA,ADGA,AENA,ACHA,ACHA,ACHA,ApC4GA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AS3BA,AENA,ACHA,ACHA,ACHA,ApC4GA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AQxBA,AlCsGA;AuBpEA,ALeA,AS3BA,AS3BA,AENA,ACHA,ACHA,AENA,ADGA,ApC4GA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AS3BA,AENA,ACHA,ACHA,AENA,ADGA,ApC4GA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AS3BA,AENA,ACHA,ACHA,AENA,ADGA,ApC4GA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AWjCA,ACHA,ACHA,AENA,ADGA,AENA,AtCkHA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,ACHA,AENA,ADGA,AENA,AtCkHA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,ACHA,AENA,ADGA,AENA,AtCkHA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,ACHA,AENA,ADGA,AGTA,ADGA,AtCkHA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,ACHA,AENA,ADGA,AGTA,ADGA,AtCkHA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,ACHA,AENA,ADGA,AGTA,ADGA,AtCkHA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,ACHA,AENA,ADGA,AGTA,ACHA,AFMA,AtCkHA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,ACHA,AENA,ADGA,AGTA,ACHA,AFMA,AtCkHA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,ACHA,AENA,ADGA,AGTA,ACHA,AFMA,AtCkHA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,AGTA,ADGA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,AGTA,ADGA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,AGTA,ADGA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,A1B8EA;AuBpEA,ALeA,AS3BA,AYpCA,AGTA,ADGA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AqB/DA,A/C6IA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AqB/DA,A/C6IA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AqB/DA,A/C6IA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AqB/DA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AqB/DA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AqB/DA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AuBrEA,AFMA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AuBrEA,AFMA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AGTA,ACHA,AFMA,AGTA,AzC2HA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AuBrEA,AFMA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AGTA,ACHA,AFMA,AGTA,AIZA,A7CuIA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AuBrEA,AFMA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AIZA,AFMA,AGTA,AIZA,A7CuIA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A8B1FA,AuBrEA,AFMA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AENA,AIZA,AFMA,AGTA,AIZA,A7CuIA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AFMA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AYpCA,AV8BA,AIZA,AFMA,AGTA,AIZA,A7CuIA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AFMA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AYpCA,AV8BA,AIZA,ACHA,AIZA,A7CuIA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AFMA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AYpCA,AV8BA,AIZA,ACHA,AIZA,A7CuIA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AFMA,ACHA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AYpCA,AV8BA,AIZA,ACHA,AIZA,A7CuIA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AFMA,AKfA,AJYA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AYpCA,ANkBA,ACHA,AIZA,A7CuIA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AFMA,AKfA,AJYA,AhDgJA;AuBpEA,ALeA,AS3BA,AYpCA,AYpCA,ANkBA,ACHA,AIZA,A7CuIA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ANkBA,ACHA,AIZA,AGTA,AhDgJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ANkBA,ACHA,AIZA,AGTA,AhDgJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ANkBA,ACHA,AIZA,AGTA,AhDgJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ANkBA,ACHA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ANkBA,ACHA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ANkBA,ACHA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,AqD/JA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ANkBA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ANkBA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ANkBA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,APqBA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,APqBA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,APqBA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AIZA,AGTA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AJYA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,AV8BA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,AV8BA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,AIZA,AHSA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,AV8BA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA;AuBpEA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA,A4DpLA;ArCgHA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA,A4DpLA;ArCgHA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA,A4DpLA;ArCgHA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A2DjLA,ACHA,ACHA,ARwBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA,A4DpLA,ACHA;AtCmHA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA,A4DpLA,ACHA;AtCmHA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA,A4DpLA,ACHA;AtCmHA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA,A4DpLA,ACHA,ACHA;AvCsHA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AMlBA,ACHA,AXiCA,AhDgJA,A4DpLA,ACHA,ACHA;AvCsHA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,ACHA,AGTA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,AXiCA,AhDgJA,A4DpLA,ACHA,ACHA;AvCsHA,ALeA,AqB/DA,AYpCA,ALeA,AOrBA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,AXiCA,AhDgJA,A4DpLA,ACHA,AENA,ADGA;AvCsHA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,AXiCA,AhDgJA,A4DpLA,ACHA,AENA,ADGA;AvCsHA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,AXiCA,AhDgJA,A4DpLA,ACHA,AENA,ADGA;AvCsHA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,AXiCA,AhDgJA,A4DpLA,ACHA,AENA,ADGA,AENA;AzC4HA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,AXiCA,AhDgJA,A4DpLA,ACHA,AENA,ADGA,AENA;AzC4HA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,AXiCA,AhDgJA,A4DpLA,ACHA,AENA,ADGA,AENA;AzC4HA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,AXiCA,AhDgJA,A4DpLA,ACHA,AENA,ADGA,AENA,ACHA;A1C+HA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,A3DiLA,A4DpLA,ACHA,AENA,ADGA,AENA,ACHA;A1C+HA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,A3DiLA,A4DpLA,ACHA,AENA,ADGA,AENA,ACHA;A1C+HA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,A3DiLA,A4DpLA,ACHA,AENA,ADGA,AENA,ACHA,ACHA;A3CkIA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,A3DiLA,A4DpLA,AGTA,ADGA,AENA,ACHA,ACHA;A3CkIA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,A3DiLA,A4DpLA,AGTA,ACHA,ACHA,ACHA;A3CkIA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,A3DiLA,A4DpLA,AGTA,ACHA,ACHA,ACHA,ACHA;A5CqIA,ALeA,AqB/DA,AYpCA,AENA,ACHA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,A3DiLA,A4DpLA,AGTA,ACHA,ACHA,ACHA,ACHA;A5CqIA,ALeA,AqB/DA,AYpCA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,A3DiLA,A4DpLA,AGTA,ACHA,ACHA,ACHA,ACHA;A5CqIA,ALeA,AqB/DA,AYpCA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,APqBA,AGTA,AOrBA,A3DiLA,A4DpLA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;A7CwIA,ALeA,AqB/DA,AYpCA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,AJYA,AOrBA,A3DiLA,A4DpLA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;A7CwIA,ALeA,AqB/DA,AYpCA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,A4DpLA,AJYA,AOrBA,A3DiLA,A4DpLA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA;A7CwIA,ALeA,AqB/DA,AYpCA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,A4DpLA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,A4DpLA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,A+D7LA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,A+D7LA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,A+D7LA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,A+D7LA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,A+D7LA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,A+D7LA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA,ACHA,AENA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA,ACHA,AENA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA,ACHA,AENA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA,ACHA,AENA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA,ACHA,AENA,ACHA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA,ACHA,AGTA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA,ACHA,AGTA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA,AIZA;A9C2IA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AiCnGA,AGTA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AoC5GA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AoC5GA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AoC5GA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,AOrBA,A3DiLA,AgEhMA,ACHA;A1C+HA,ALeA,AoC5GA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AgEhMA,ACHA;A1C+HA,ALeA,AoC5GA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AoC5GA,AjDmJA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AwDxKA,ApD4JA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,ANkBA,AZoCA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA,AiEnMA;A1C+HA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,ACHA,AIZA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,AKfA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,AKfA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,AKfA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,AKfA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,AKfA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,AKfA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,AKfA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,AKfA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AIZA,AKfA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AS3BA,AlBsDA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,AT2BA,AIZA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AbuCA,ALeA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA,AlBsDA;AuBpEA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  react: true,\n  assertNode: true,\n  createTypeAnnotationBasedOnTypeof: true,\n  createUnionTypeAnnotation: true,\n  cloneNode: true,\n  clone: true,\n  cloneDeep: true,\n  cloneWithoutLoc: true,\n  addComment: true,\n  addComments: true,\n  inheritInnerComments: true,\n  inheritLeadingComments: true,\n  inheritsComments: true,\n  inheritTrailingComments: true,\n  removeComments: true,\n  ensureBlock: true,\n  toBindingIdentifierName: true,\n  toBlock: true,\n  toComputedKey: true,\n  toExpression: true,\n  toIdentifier: true,\n  toKeyAlias: true,\n  toSequenceExpression: true,\n  toStatement: true,\n  valueToNode: true,\n  appendToMemberExpression: true,\n  inherits: true,\n  prependToMemberExpression: true,\n  removeProperties: true,\n  removePropertiesDeep: true,\n  removeTypeDuplicates: true,\n  getBindingIdentifiers: true,\n  getOuterBindingIdentifiers: true,\n  traverse: true,\n  traverseFast: true,\n  shallowEqual: true,\n  is: true,\n  isBinding: true,\n  isBlockScoped: true,\n  isImmutable: true,\n  isLet: true,\n  isNode: true,\n  isNodesEquivalent: true,\n  isReferenced: true,\n  isScope: true,\n  isSpecifierDefault: true,\n  isType: true,\n  isValidES3Identifier: true,\n  isValidIdentifier: true,\n  isVar: true,\n  matchesPattern: true,\n  validate: true,\n  buildMatchMemberExpression: true\n};\nObject.defineProperty(exports, \"assertNode\", {\n  enumerable: true,\n  get: function get() {\n    return _assertNode.default;\n  }\n});\nObject.defineProperty(exports, \"createTypeAnnotationBasedOnTypeof\", {\n  enumerable: true,\n  get: function get() {\n    return _createTypeAnnotationBasedOnTypeof.default;\n  }\n});\nObject.defineProperty(exports, \"createUnionTypeAnnotation\", {\n  enumerable: true,\n  get: function get() {\n    return _createUnionTypeAnnotation.default;\n  }\n});\nObject.defineProperty(exports, \"cloneNode\", {\n  enumerable: true,\n  get: function get() {\n    return _cloneNode.default;\n  }\n});\nObject.defineProperty(exports, \"clone\", {\n  enumerable: true,\n  get: function get() {\n    return _clone.default;\n  }\n});\nObject.defineProperty(exports, \"cloneDeep\", {\n  enumerable: true,\n  get: function get() {\n    return _cloneDeep.default;\n  }\n});\nObject.defineProperty(exports, \"cloneWithoutLoc\", {\n  enumerable: true,\n  get: function get() {\n    return _cloneWithoutLoc.default;\n  }\n});\nObject.defineProperty(exports, \"addComment\", {\n  enumerable: true,\n  get: function get() {\n    return _addComment.default;\n  }\n});\nObject.defineProperty(exports, \"addComments\", {\n  enumerable: true,\n  get: function get() {\n    return _addComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritInnerComments\", {\n  enumerable: true,\n  get: function get() {\n    return _inheritInnerComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritLeadingComments\", {\n  enumerable: true,\n  get: function get() {\n    return _inheritLeadingComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritsComments\", {\n  enumerable: true,\n  get: function get() {\n    return _inheritsComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritTrailingComments\", {\n  enumerable: true,\n  get: function get() {\n    return _inheritTrailingComments.default;\n  }\n});\nObject.defineProperty(exports, \"removeComments\", {\n  enumerable: true,\n  get: function get() {\n    return _removeComments.default;\n  }\n});\nObject.defineProperty(exports, \"ensureBlock\", {\n  enumerable: true,\n  get: function get() {\n    return _ensureBlock.default;\n  }\n});\nObject.defineProperty(exports, \"toBindingIdentifierName\", {\n  enumerable: true,\n  get: function get() {\n    return _toBindingIdentifierName.default;\n  }\n});\nObject.defineProperty(exports, \"toBlock\", {\n  enumerable: true,\n  get: function get() {\n    return _toBlock.default;\n  }\n});\nObject.defineProperty(exports, \"toComputedKey\", {\n  enumerable: true,\n  get: function get() {\n    return _toComputedKey.default;\n  }\n});\nObject.defineProperty(exports, \"toExpression\", {\n  enumerable: true,\n  get: function get() {\n    return _toExpression.default;\n  }\n});\nObject.defineProperty(exports, \"toIdentifier\", {\n  enumerable: true,\n  get: function get() {\n    return _toIdentifier.default;\n  }\n});\nObject.defineProperty(exports, \"toKeyAlias\", {\n  enumerable: true,\n  get: function get() {\n    return _toKeyAlias.default;\n  }\n});\nObject.defineProperty(exports, \"toSequenceExpression\", {\n  enumerable: true,\n  get: function get() {\n    return _toSequenceExpression.default;\n  }\n});\nObject.defineProperty(exports, \"toStatement\", {\n  enumerable: true,\n  get: function get() {\n    return _toStatement.default;\n  }\n});\nObject.defineProperty(exports, \"valueToNode\", {\n  enumerable: true,\n  get: function get() {\n    return _valueToNode.default;\n  }\n});\nObject.defineProperty(exports, \"appendToMemberExpression\", {\n  enumerable: true,\n  get: function get() {\n    return _appendToMemberExpression.default;\n  }\n});\nObject.defineProperty(exports, \"inherits\", {\n  enumerable: true,\n  get: function get() {\n    return _inherits.default;\n  }\n});\nObject.defineProperty(exports, \"prependToMemberExpression\", {\n  enumerable: true,\n  get: function get() {\n    return _prependToMemberExpression.default;\n  }\n});\nObject.defineProperty(exports, \"removeProperties\", {\n  enumerable: true,\n  get: function get() {\n    return _removeProperties.default;\n  }\n});\nObject.defineProperty(exports, \"removePropertiesDeep\", {\n  enumerable: true,\n  get: function get() {\n    return _removePropertiesDeep.default;\n  }\n});\nObject.defineProperty(exports, \"removeTypeDuplicates\", {\n  enumerable: true,\n  get: function get() {\n    return _removeTypeDuplicates.default;\n  }\n});\nObject.defineProperty(exports, \"getBindingIdentifiers\", {\n  enumerable: true,\n  get: function get() {\n    return _getBindingIdentifiers.default;\n  }\n});\nObject.defineProperty(exports, \"getOuterBindingIdentifiers\", {\n  enumerable: true,\n  get: function get() {\n    return _getOuterBindingIdentifiers.default;\n  }\n});\nObject.defineProperty(exports, \"traverse\", {\n  enumerable: true,\n  get: function get() {\n    return _traverse.default;\n  }\n});\nObject.defineProperty(exports, \"traverseFast\", {\n  enumerable: true,\n  get: function get() {\n    return _traverseFast.default;\n  }\n});\nObject.defineProperty(exports, \"shallowEqual\", {\n  enumerable: true,\n  get: function get() {\n    return _shallowEqual.default;\n  }\n});\nObject.defineProperty(exports, \"is\", {\n  enumerable: true,\n  get: function get() {\n    return _is.default;\n  }\n});\nObject.defineProperty(exports, \"isBinding\", {\n  enumerable: true,\n  get: function get() {\n    return _isBinding.default;\n  }\n});\nObject.defineProperty(exports, \"isBlockScoped\", {\n  enumerable: true,\n  get: function get() {\n    return _isBlockScoped.default;\n  }\n});\nObject.defineProperty(exports, \"isImmutable\", {\n  enumerable: true,\n  get: function get() {\n    return _isImmutable.default;\n  }\n});\nObject.defineProperty(exports, \"isLet\", {\n  enumerable: true,\n  get: function get() {\n    return _isLet.default;\n  }\n});\nObject.defineProperty(exports, \"isNode\", {\n  enumerable: true,\n  get: function get() {\n    return _isNode.default;\n  }\n});\nObject.defineProperty(exports, \"isNodesEquivalent\", {\n  enumerable: true,\n  get: function get() {\n    return _isNodesEquivalent.default;\n  }\n});\nObject.defineProperty(exports, \"isReferenced\", {\n  enumerable: true,\n  get: function get() {\n    return _isReferenced.default;\n  }\n});\nObject.defineProperty(exports, \"isScope\", {\n  enumerable: true,\n  get: function get() {\n    return _isScope.default;\n  }\n});\nObject.defineProperty(exports, \"isSpecifierDefault\", {\n  enumerable: true,\n  get: function get() {\n    return _isSpecifierDefault.default;\n  }\n});\nObject.defineProperty(exports, \"isType\", {\n  enumerable: true,\n  get: function get() {\n    return _isType.default;\n  }\n});\nObject.defineProperty(exports, \"isValidES3Identifier\", {\n  enumerable: true,\n  get: function get() {\n    return _isValidES3Identifier.default;\n  }\n});\nObject.defineProperty(exports, \"isValidIdentifier\", {\n  enumerable: true,\n  get: function get() {\n    return _isValidIdentifier.default;\n  }\n});\nObject.defineProperty(exports, \"isVar\", {\n  enumerable: true,\n  get: function get() {\n    return _isVar.default;\n  }\n});\nObject.defineProperty(exports, \"matchesPattern\", {\n  enumerable: true,\n  get: function get() {\n    return _matchesPattern.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function get() {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"buildMatchMemberExpression\", {\n  enumerable: true,\n  get: function get() {\n    return _buildMatchMemberExpression.default;\n  }\n});\nexports.react = void 0;\n\nvar _isReactComponent = _interopRequireDefault(require(\"./validators/react/isReactComponent\"));\n\nvar _isCompatTag = _interopRequireDefault(require(\"./validators/react/isCompatTag\"));\n\nvar _buildChildren = _interopRequireDefault(require(\"./builders/react/buildChildren\"));\n\nvar _assertNode = _interopRequireDefault(require(\"./asserts/assertNode\"));\n\nvar _generated = require(\"./asserts/generated\");\n\nObject.keys(_generated).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _generated[key];\n    }\n  });\n});\n\nvar _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(require(\"./builders/flow/createTypeAnnotationBasedOnTypeof\"));\n\nvar _createUnionTypeAnnotation = _interopRequireDefault(require(\"./builders/flow/createUnionTypeAnnotation\"));\n\nvar _generated2 = require(\"./builders/generated\");\n\nObject.keys(_generated2).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _generated2[key];\n    }\n  });\n});\n\nvar _cloneNode = _interopRequireDefault(require(\"./clone/cloneNode\"));\n\nvar _clone = _interopRequireDefault(require(\"./clone/clone\"));\n\nvar _cloneDeep = _interopRequireDefault(require(\"./clone/cloneDeep\"));\n\nvar _cloneWithoutLoc = _interopRequireDefault(require(\"./clone/cloneWithoutLoc\"));\n\nvar _addComment = _interopRequireDefault(require(\"./comments/addComment\"));\n\nvar _addComments = _interopRequireDefault(require(\"./comments/addComments\"));\n\nvar _inheritInnerComments = _interopRequireDefault(require(\"./comments/inheritInnerComments\"));\n\nvar _inheritLeadingComments = _interopRequireDefault(require(\"./comments/inheritLeadingComments\"));\n\nvar _inheritsComments = _interopRequireDefault(require(\"./comments/inheritsComments\"));\n\nvar _inheritTrailingComments = _interopRequireDefault(require(\"./comments/inheritTrailingComments\"));\n\nvar _removeComments = _interopRequireDefault(require(\"./comments/removeComments\"));\n\nvar _generated3 = require(\"./constants/generated\");\n\nObject.keys(_generated3).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _generated3[key];\n    }\n  });\n});\n\nvar _constants = require(\"./constants\");\n\nObject.keys(_constants).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _constants[key];\n    }\n  });\n});\n\nvar _ensureBlock = _interopRequireDefault(require(\"./converters/ensureBlock\"));\n\nvar _toBindingIdentifierName = _interopRequireDefault(require(\"./converters/toBindingIdentifierName\"));\n\nvar _toBlock = _interopRequireDefault(require(\"./converters/toBlock\"));\n\nvar _toComputedKey = _interopRequireDefault(require(\"./converters/toComputedKey\"));\n\nvar _toExpression = _interopRequireDefault(require(\"./converters/toExpression\"));\n\nvar _toIdentifier = _interopRequireDefault(require(\"./converters/toIdentifier\"));\n\nvar _toKeyAlias = _interopRequireDefault(require(\"./converters/toKeyAlias\"));\n\nvar _toSequenceExpression = _interopRequireDefault(require(\"./converters/toSequenceExpression\"));\n\nvar _toStatement = _interopRequireDefault(require(\"./converters/toStatement\"));\n\nvar _valueToNode = _interopRequireDefault(require(\"./converters/valueToNode\"));\n\nvar _definitions = require(\"./definitions\");\n\nObject.keys(_definitions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _definitions[key];\n    }\n  });\n});\n\nvar _appendToMemberExpression = _interopRequireDefault(require(\"./modifications/appendToMemberExpression\"));\n\nvar _inherits = _interopRequireDefault(require(\"./modifications/inherits\"));\n\nvar _prependToMemberExpression = _interopRequireDefault(require(\"./modifications/prependToMemberExpression\"));\n\nvar _removeProperties = _interopRequireDefault(require(\"./modifications/removeProperties\"));\n\nvar _removePropertiesDeep = _interopRequireDefault(require(\"./modifications/removePropertiesDeep\"));\n\nvar _removeTypeDuplicates = _interopRequireDefault(require(\"./modifications/flow/removeTypeDuplicates\"));\n\nvar _getBindingIdentifiers = _interopRequireDefault(require(\"./retrievers/getBindingIdentifiers\"));\n\nvar _getOuterBindingIdentifiers = _interopRequireDefault(require(\"./retrievers/getOuterBindingIdentifiers\"));\n\nvar _traverse = _interopRequireDefault(require(\"./traverse/traverse\"));\n\nvar _traverseFast = _interopRequireDefault(require(\"./traverse/traverseFast\"));\n\nvar _shallowEqual = _interopRequireDefault(require(\"./utils/shallowEqual\"));\n\nvar _is = _interopRequireDefault(require(\"./validators/is\"));\n\nvar _isBinding = _interopRequireDefault(require(\"./validators/isBinding\"));\n\nvar _isBlockScoped = _interopRequireDefault(require(\"./validators/isBlockScoped\"));\n\nvar _isImmutable = _interopRequireDefault(require(\"./validators/isImmutable\"));\n\nvar _isLet = _interopRequireDefault(require(\"./validators/isLet\"));\n\nvar _isNode = _interopRequireDefault(require(\"./validators/isNode\"));\n\nvar _isNodesEquivalent = _interopRequireDefault(require(\"./validators/isNodesEquivalent\"));\n\nvar _isReferenced = _interopRequireDefault(require(\"./validators/isReferenced\"));\n\nvar _isScope = _interopRequireDefault(require(\"./validators/isScope\"));\n\nvar _isSpecifierDefault = _interopRequireDefault(require(\"./validators/isSpecifierDefault\"));\n\nvar _isType = _interopRequireDefault(require(\"./validators/isType\"));\n\nvar _isValidES3Identifier = _interopRequireDefault(require(\"./validators/isValidES3Identifier\"));\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"./validators/isValidIdentifier\"));\n\nvar _isVar = _interopRequireDefault(require(\"./validators/isVar\"));\n\nvar _matchesPattern = _interopRequireDefault(require(\"./validators/matchesPattern\"));\n\nvar _validate = _interopRequireDefault(require(\"./validators/validate\"));\n\nvar _buildMatchMemberExpression = _interopRequireDefault(require(\"./validators/buildMatchMemberExpression\"));\n\nvar _generated4 = require(\"./validators/generated\");\n\nObject.keys(_generated4).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _generated4[key];\n    }\n  });\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar react = {\n  isReactComponent: _isReactComponent.default,\n  isCompatTag: _isCompatTag.default,\n  buildChildren: _buildChildren.default\n};\nexports.react = react;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buildMatchMemberExpression = _interopRequireDefault(require(\"../buildMatchMemberExpression\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar isReactComponent = (0, _buildMatchMemberExpression.default)(\"React.Component\");\nvar _default = isReactComponent;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = buildMatchMemberExpression;\n\nvar _matchesPattern = _interopRequireDefault(require(\"./matchesPattern\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction buildMatchMemberExpression(match, allowPartial) {\n  var parts = match.split(\".\");\n  return function (member) {\n    return (0, _matchesPattern.default)(member, parts, allowPartial);\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = matchesPattern;\n\nvar _generated = require(\"./generated\");\n\nfunction matchesPattern(member, match, allowPartial) {\n  if (!(0, _generated.isMemberExpression)(member)) return false;\n  var parts = Array.isArray(match) ? match : match.split(\".\");\n  var nodes = [];\n  var node;\n\n  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {\n    nodes.push(node.property);\n  }\n\n  nodes.push(node);\n  if (nodes.length < parts.length) return false;\n  if (!allowPartial && nodes.length > parts.length) return false;\n\n  for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {\n    var _node = nodes[j];\n    var value = void 0;\n\n    if ((0, _generated.isIdentifier)(_node)) {\n      value = _node.name;\n    } else if ((0, _generated.isStringLiteral)(_node)) {\n      value = _node.value;\n    } else {\n      return false;\n    }\n\n    if (parts[i] !== value) return false;\n  }\n\n  return true;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isArrayExpression = isArrayExpression;\nexports.isAssignmentExpression = isAssignmentExpression;\nexports.isBinaryExpression = isBinaryExpression;\nexports.isDirective = isDirective;\nexports.isDirectiveLiteral = isDirectiveLiteral;\nexports.isBlockStatement = isBlockStatement;\nexports.isBreakStatement = isBreakStatement;\nexports.isCallExpression = isCallExpression;\nexports.isCatchClause = isCatchClause;\nexports.isConditionalExpression = isConditionalExpression;\nexports.isContinueStatement = isContinueStatement;\nexports.isDebuggerStatement = isDebuggerStatement;\nexports.isDoWhileStatement = isDoWhileStatement;\nexports.isEmptyStatement = isEmptyStatement;\nexports.isExpressionStatement = isExpressionStatement;\nexports.isFile = isFile;\nexports.isForInStatement = isForInStatement;\nexports.isForStatement = isForStatement;\nexports.isFunctionDeclaration = isFunctionDeclaration;\nexports.isFunctionExpression = isFunctionExpression;\nexports.isIdentifier = isIdentifier;\nexports.isIfStatement = isIfStatement;\nexports.isLabeledStatement = isLabeledStatement;\nexports.isStringLiteral = isStringLiteral;\nexports.isNumericLiteral = isNumericLiteral;\nexports.isNullLiteral = isNullLiteral;\nexports.isBooleanLiteral = isBooleanLiteral;\nexports.isRegExpLiteral = isRegExpLiteral;\nexports.isLogicalExpression = isLogicalExpression;\nexports.isMemberExpression = isMemberExpression;\nexports.isNewExpression = isNewExpression;\nexports.isProgram = isProgram;\nexports.isObjectExpression = isObjectExpression;\nexports.isObjectMethod = isObjectMethod;\nexports.isObjectProperty = isObjectProperty;\nexports.isRestElement = isRestElement;\nexports.isReturnStatement = isReturnStatement;\nexports.isSequenceExpression = isSequenceExpression;\nexports.isSwitchCase = isSwitchCase;\nexports.isSwitchStatement = isSwitchStatement;\nexports.isThisExpression = isThisExpression;\nexports.isThrowStatement = isThrowStatement;\nexports.isTryStatement = isTryStatement;\nexports.isUnaryExpression = isUnaryExpression;\nexports.isUpdateExpression = isUpdateExpression;\nexports.isVariableDeclaration = isVariableDeclaration;\nexports.isVariableDeclarator = isVariableDeclarator;\nexports.isWhileStatement = isWhileStatement;\nexports.isWithStatement = isWithStatement;\nexports.isAssignmentPattern = isAssignmentPattern;\nexports.isArrayPattern = isArrayPattern;\nexports.isArrowFunctionExpression = isArrowFunctionExpression;\nexports.isClassBody = isClassBody;\nexports.isClassDeclaration = isClassDeclaration;\nexports.isClassExpression = isClassExpression;\nexports.isExportAllDeclaration = isExportAllDeclaration;\nexports.isExportDefaultDeclaration = isExportDefaultDeclaration;\nexports.isExportNamedDeclaration = isExportNamedDeclaration;\nexports.isExportSpecifier = isExportSpecifier;\nexports.isForOfStatement = isForOfStatement;\nexports.isImportDeclaration = isImportDeclaration;\nexports.isImportDefaultSpecifier = isImportDefaultSpecifier;\nexports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;\nexports.isImportSpecifier = isImportSpecifier;\nexports.isMetaProperty = isMetaProperty;\nexports.isClassMethod = isClassMethod;\nexports.isObjectPattern = isObjectPattern;\nexports.isSpreadElement = isSpreadElement;\nexports.isSuper = isSuper;\nexports.isTaggedTemplateExpression = isTaggedTemplateExpression;\nexports.isTemplateElement = isTemplateElement;\nexports.isTemplateLiteral = isTemplateLiteral;\nexports.isYieldExpression = isYieldExpression;\nexports.isAnyTypeAnnotation = isAnyTypeAnnotation;\nexports.isArrayTypeAnnotation = isArrayTypeAnnotation;\nexports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;\nexports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;\nexports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;\nexports.isClassImplements = isClassImplements;\nexports.isDeclareClass = isDeclareClass;\nexports.isDeclareFunction = isDeclareFunction;\nexports.isDeclareInterface = isDeclareInterface;\nexports.isDeclareModule = isDeclareModule;\nexports.isDeclareModuleExports = isDeclareModuleExports;\nexports.isDeclareTypeAlias = isDeclareTypeAlias;\nexports.isDeclareOpaqueType = isDeclareOpaqueType;\nexports.isDeclareVariable = isDeclareVariable;\nexports.isDeclareExportDeclaration = isDeclareExportDeclaration;\nexports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;\nexports.isDeclaredPredicate = isDeclaredPredicate;\nexports.isExistsTypeAnnotation = isExistsTypeAnnotation;\nexports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;\nexports.isFunctionTypeParam = isFunctionTypeParam;\nexports.isGenericTypeAnnotation = isGenericTypeAnnotation;\nexports.isInferredPredicate = isInferredPredicate;\nexports.isInterfaceExtends = isInterfaceExtends;\nexports.isInterfaceDeclaration = isInterfaceDeclaration;\nexports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;\nexports.isMixedTypeAnnotation = isMixedTypeAnnotation;\nexports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;\nexports.isNullableTypeAnnotation = isNullableTypeAnnotation;\nexports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;\nexports.isNumberTypeAnnotation = isNumberTypeAnnotation;\nexports.isObjectTypeAnnotation = isObjectTypeAnnotation;\nexports.isObjectTypeCallProperty = isObjectTypeCallProperty;\nexports.isObjectTypeIndexer = isObjectTypeIndexer;\nexports.isObjectTypeProperty = isObjectTypeProperty;\nexports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;\nexports.isOpaqueType = isOpaqueType;\nexports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;\nexports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;\nexports.isStringTypeAnnotation = isStringTypeAnnotation;\nexports.isThisTypeAnnotation = isThisTypeAnnotation;\nexports.isTupleTypeAnnotation = isTupleTypeAnnotation;\nexports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;\nexports.isTypeAlias = isTypeAlias;\nexports.isTypeAnnotation = isTypeAnnotation;\nexports.isTypeCastExpression = isTypeCastExpression;\nexports.isTypeParameter = isTypeParameter;\nexports.isTypeParameterDeclaration = isTypeParameterDeclaration;\nexports.isTypeParameterInstantiation = isTypeParameterInstantiation;\nexports.isUnionTypeAnnotation = isUnionTypeAnnotation;\nexports.isVariance = isVariance;\nexports.isVoidTypeAnnotation = isVoidTypeAnnotation;\nexports.isJSXAttribute = isJSXAttribute;\nexports.isJSXClosingElement = isJSXClosingElement;\nexports.isJSXElement = isJSXElement;\nexports.isJSXEmptyExpression = isJSXEmptyExpression;\nexports.isJSXExpressionContainer = isJSXExpressionContainer;\nexports.isJSXSpreadChild = isJSXSpreadChild;\nexports.isJSXIdentifier = isJSXIdentifier;\nexports.isJSXMemberExpression = isJSXMemberExpression;\nexports.isJSXNamespacedName = isJSXNamespacedName;\nexports.isJSXOpeningElement = isJSXOpeningElement;\nexports.isJSXSpreadAttribute = isJSXSpreadAttribute;\nexports.isJSXText = isJSXText;\nexports.isJSXFragment = isJSXFragment;\nexports.isJSXOpeningFragment = isJSXOpeningFragment;\nexports.isJSXClosingFragment = isJSXClosingFragment;\nexports.isNoop = isNoop;\nexports.isParenthesizedExpression = isParenthesizedExpression;\nexports.isAwaitExpression = isAwaitExpression;\nexports.isBindExpression = isBindExpression;\nexports.isClassProperty = isClassProperty;\nexports.isOptionalMemberExpression = isOptionalMemberExpression;\nexports.isOptionalCallExpression = isOptionalCallExpression;\nexports.isImport = isImport;\nexports.isDecorator = isDecorator;\nexports.isDoExpression = isDoExpression;\nexports.isExportDefaultSpecifier = isExportDefaultSpecifier;\nexports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;\nexports.isTSParameterProperty = isTSParameterProperty;\nexports.isTSDeclareFunction = isTSDeclareFunction;\nexports.isTSDeclareMethod = isTSDeclareMethod;\nexports.isTSQualifiedName = isTSQualifiedName;\nexports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;\nexports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;\nexports.isTSPropertySignature = isTSPropertySignature;\nexports.isTSMethodSignature = isTSMethodSignature;\nexports.isTSIndexSignature = isTSIndexSignature;\nexports.isTSAnyKeyword = isTSAnyKeyword;\nexports.isTSNumberKeyword = isTSNumberKeyword;\nexports.isTSObjectKeyword = isTSObjectKeyword;\nexports.isTSBooleanKeyword = isTSBooleanKeyword;\nexports.isTSStringKeyword = isTSStringKeyword;\nexports.isTSSymbolKeyword = isTSSymbolKeyword;\nexports.isTSVoidKeyword = isTSVoidKeyword;\nexports.isTSUndefinedKeyword = isTSUndefinedKeyword;\nexports.isTSNullKeyword = isTSNullKeyword;\nexports.isTSNeverKeyword = isTSNeverKeyword;\nexports.isTSThisType = isTSThisType;\nexports.isTSFunctionType = isTSFunctionType;\nexports.isTSConstructorType = isTSConstructorType;\nexports.isTSTypeReference = isTSTypeReference;\nexports.isTSTypePredicate = isTSTypePredicate;\nexports.isTSTypeQuery = isTSTypeQuery;\nexports.isTSTypeLiteral = isTSTypeLiteral;\nexports.isTSArrayType = isTSArrayType;\nexports.isTSTupleType = isTSTupleType;\nexports.isTSUnionType = isTSUnionType;\nexports.isTSIntersectionType = isTSIntersectionType;\nexports.isTSConditionalType = isTSConditionalType;\nexports.isTSInferType = isTSInferType;\nexports.isTSParenthesizedType = isTSParenthesizedType;\nexports.isTSTypeOperator = isTSTypeOperator;\nexports.isTSIndexedAccessType = isTSIndexedAccessType;\nexports.isTSMappedType = isTSMappedType;\nexports.isTSLiteralType = isTSLiteralType;\nexports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;\nexports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;\nexports.isTSInterfaceBody = isTSInterfaceBody;\nexports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;\nexports.isTSAsExpression = isTSAsExpression;\nexports.isTSTypeAssertion = isTSTypeAssertion;\nexports.isTSEnumDeclaration = isTSEnumDeclaration;\nexports.isTSEnumMember = isTSEnumMember;\nexports.isTSModuleDeclaration = isTSModuleDeclaration;\nexports.isTSModuleBlock = isTSModuleBlock;\nexports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;\nexports.isTSExternalModuleReference = isTSExternalModuleReference;\nexports.isTSNonNullExpression = isTSNonNullExpression;\nexports.isTSExportAssignment = isTSExportAssignment;\nexports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;\nexports.isTSTypeAnnotation = isTSTypeAnnotation;\nexports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;\nexports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;\nexports.isTSTypeParameter = isTSTypeParameter;\nexports.isExpression = isExpression;\nexports.isBinary = isBinary;\nexports.isScopable = isScopable;\nexports.isBlockParent = isBlockParent;\nexports.isBlock = isBlock;\nexports.isStatement = isStatement;\nexports.isTerminatorless = isTerminatorless;\nexports.isCompletionStatement = isCompletionStatement;\nexports.isConditional = isConditional;\nexports.isLoop = isLoop;\nexports.isWhile = isWhile;\nexports.isExpressionWrapper = isExpressionWrapper;\nexports.isFor = isFor;\nexports.isForXStatement = isForXStatement;\nexports.isFunction = isFunction;\nexports.isFunctionParent = isFunctionParent;\nexports.isPureish = isPureish;\nexports.isDeclaration = isDeclaration;\nexports.isPatternLike = isPatternLike;\nexports.isLVal = isLVal;\nexports.isTSEntityName = isTSEntityName;\nexports.isLiteral = isLiteral;\nexports.isImmutable = isImmutable;\nexports.isUserWhitespacable = isUserWhitespacable;\nexports.isMethod = isMethod;\nexports.isObjectMember = isObjectMember;\nexports.isProperty = isProperty;\nexports.isUnaryLike = isUnaryLike;\nexports.isPattern = isPattern;\nexports.isClass = isClass;\nexports.isModuleDeclaration = isModuleDeclaration;\nexports.isExportDeclaration = isExportDeclaration;\nexports.isModuleSpecifier = isModuleSpecifier;\nexports.isFlow = isFlow;\nexports.isFlowType = isFlowType;\nexports.isFlowBaseAnnotation = isFlowBaseAnnotation;\nexports.isFlowDeclaration = isFlowDeclaration;\nexports.isFlowPredicate = isFlowPredicate;\nexports.isJSX = isJSX;\nexports.isTSTypeElement = isTSTypeElement;\nexports.isTSType = isTSType;\nexports.isNumberLiteral = isNumberLiteral;\nexports.isRegexLiteral = isRegexLiteral;\nexports.isRestProperty = isRestProperty;\nexports.isSpreadProperty = isSpreadProperty;\n\nvar _is = _interopRequireDefault(require(\"../is\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isArrayExpression(node, opts) {\n  return (0, _is.default)(\"ArrayExpression\", node, opts);\n}\n\nfunction isAssignmentExpression(node, opts) {\n  return (0, _is.default)(\"AssignmentExpression\", node, opts);\n}\n\nfunction isBinaryExpression(node, opts) {\n  return (0, _is.default)(\"BinaryExpression\", node, opts);\n}\n\nfunction isDirective(node, opts) {\n  return (0, _is.default)(\"Directive\", node, opts);\n}\n\nfunction isDirectiveLiteral(node, opts) {\n  return (0, _is.default)(\"DirectiveLiteral\", node, opts);\n}\n\nfunction isBlockStatement(node, opts) {\n  return (0, _is.default)(\"BlockStatement\", node, opts);\n}\n\nfunction isBreakStatement(node, opts) {\n  return (0, _is.default)(\"BreakStatement\", node, opts);\n}\n\nfunction isCallExpression(node, opts) {\n  return (0, _is.default)(\"CallExpression\", node, opts);\n}\n\nfunction isCatchClause(node, opts) {\n  return (0, _is.default)(\"CatchClause\", node, opts);\n}\n\nfunction isConditionalExpression(node, opts) {\n  return (0, _is.default)(\"ConditionalExpression\", node, opts);\n}\n\nfunction isContinueStatement(node, opts) {\n  return (0, _is.default)(\"ContinueStatement\", node, opts);\n}\n\nfunction isDebuggerStatement(node, opts) {\n  return (0, _is.default)(\"DebuggerStatement\", node, opts);\n}\n\nfunction isDoWhileStatement(node, opts) {\n  return (0, _is.default)(\"DoWhileStatement\", node, opts);\n}\n\nfunction isEmptyStatement(node, opts) {\n  return (0, _is.default)(\"EmptyStatement\", node, opts);\n}\n\nfunction isExpressionStatement(node, opts) {\n  return (0, _is.default)(\"ExpressionStatement\", node, opts);\n}\n\nfunction isFile(node, opts) {\n  return (0, _is.default)(\"File\", node, opts);\n}\n\nfunction isForInStatement(node, opts) {\n  return (0, _is.default)(\"ForInStatement\", node, opts);\n}\n\nfunction isForStatement(node, opts) {\n  return (0, _is.default)(\"ForStatement\", node, opts);\n}\n\nfunction isFunctionDeclaration(node, opts) {\n  return (0, _is.default)(\"FunctionDeclaration\", node, opts);\n}\n\nfunction isFunctionExpression(node, opts) {\n  return (0, _is.default)(\"FunctionExpression\", node, opts);\n}\n\nfunction isIdentifier(node, opts) {\n  return (0, _is.default)(\"Identifier\", node, opts);\n}\n\nfunction isIfStatement(node, opts) {\n  return (0, _is.default)(\"IfStatement\", node, opts);\n}\n\nfunction isLabeledStatement(node, opts) {\n  return (0, _is.default)(\"LabeledStatement\", node, opts);\n}\n\nfunction isStringLiteral(node, opts) {\n  return (0, _is.default)(\"StringLiteral\", node, opts);\n}\n\nfunction isNumericLiteral(node, opts) {\n  return (0, _is.default)(\"NumericLiteral\", node, opts);\n}\n\nfunction isNullLiteral(node, opts) {\n  return (0, _is.default)(\"NullLiteral\", node, opts);\n}\n\nfunction isBooleanLiteral(node, opts) {\n  return (0, _is.default)(\"BooleanLiteral\", node, opts);\n}\n\nfunction isRegExpLiteral(node, opts) {\n  return (0, _is.default)(\"RegExpLiteral\", node, opts);\n}\n\nfunction isLogicalExpression(node, opts) {\n  return (0, _is.default)(\"LogicalExpression\", node, opts);\n}\n\nfunction isMemberExpression(node, opts) {\n  return (0, _is.default)(\"MemberExpression\", node, opts);\n}\n\nfunction isNewExpression(node, opts) {\n  return (0, _is.default)(\"NewExpression\", node, opts);\n}\n\nfunction isProgram(node, opts) {\n  return (0, _is.default)(\"Program\", node, opts);\n}\n\nfunction isObjectExpression(node, opts) {\n  return (0, _is.default)(\"ObjectExpression\", node, opts);\n}\n\nfunction isObjectMethod(node, opts) {\n  return (0, _is.default)(\"ObjectMethod\", node, opts);\n}\n\nfunction isObjectProperty(node, opts) {\n  return (0, _is.default)(\"ObjectProperty\", node, opts);\n}\n\nfunction isRestElement(node, opts) {\n  return (0, _is.default)(\"RestElement\", node, opts);\n}\n\nfunction isReturnStatement(node, opts) {\n  return (0, _is.default)(\"ReturnStatement\", node, opts);\n}\n\nfunction isSequenceExpression(node, opts) {\n  return (0, _is.default)(\"SequenceExpression\", node, opts);\n}\n\nfunction isSwitchCase(node, opts) {\n  return (0, _is.default)(\"SwitchCase\", node, opts);\n}\n\nfunction isSwitchStatement(node, opts) {\n  return (0, _is.default)(\"SwitchStatement\", node, opts);\n}\n\nfunction isThisExpression(node, opts) {\n  return (0, _is.default)(\"ThisExpression\", node, opts);\n}\n\nfunction isThrowStatement(node, opts) {\n  return (0, _is.default)(\"ThrowStatement\", node, opts);\n}\n\nfunction isTryStatement(node, opts) {\n  return (0, _is.default)(\"TryStatement\", node, opts);\n}\n\nfunction isUnaryExpression(node, opts) {\n  return (0, _is.default)(\"UnaryExpression\", node, opts);\n}\n\nfunction isUpdateExpression(node, opts) {\n  return (0, _is.default)(\"UpdateExpression\", node, opts);\n}\n\nfunction isVariableDeclaration(node, opts) {\n  return (0, _is.default)(\"VariableDeclaration\", node, opts);\n}\n\nfunction isVariableDeclarator(node, opts) {\n  return (0, _is.default)(\"VariableDeclarator\", node, opts);\n}\n\nfunction isWhileStatement(node, opts) {\n  return (0, _is.default)(\"WhileStatement\", node, opts);\n}\n\nfunction isWithStatement(node, opts) {\n  return (0, _is.default)(\"WithStatement\", node, opts);\n}\n\nfunction isAssignmentPattern(node, opts) {\n  return (0, _is.default)(\"AssignmentPattern\", node, opts);\n}\n\nfunction isArrayPattern(node, opts) {\n  return (0, _is.default)(\"ArrayPattern\", node, opts);\n}\n\nfunction isArrowFunctionExpression(node, opts) {\n  return (0, _is.default)(\"ArrowFunctionExpression\", node, opts);\n}\n\nfunction isClassBody(node, opts) {\n  return (0, _is.default)(\"ClassBody\", node, opts);\n}\n\nfunction isClassDeclaration(node, opts) {\n  return (0, _is.default)(\"ClassDeclaration\", node, opts);\n}\n\nfunction isClassExpression(node, opts) {\n  return (0, _is.default)(\"ClassExpression\", node, opts);\n}\n\nfunction isExportAllDeclaration(node, opts) {\n  return (0, _is.default)(\"ExportAllDeclaration\", node, opts);\n}\n\nfunction isExportDefaultDeclaration(node, opts) {\n  return (0, _is.default)(\"ExportDefaultDeclaration\", node, opts);\n}\n\nfunction isExportNamedDeclaration(node, opts) {\n  return (0, _is.default)(\"ExportNamedDeclaration\", node, opts);\n}\n\nfunction isExportSpecifier(node, opts) {\n  return (0, _is.default)(\"ExportSpecifier\", node, opts);\n}\n\nfunction isForOfStatement(node, opts) {\n  return (0, _is.default)(\"ForOfStatement\", node, opts);\n}\n\nfunction isImportDeclaration(node, opts) {\n  return (0, _is.default)(\"ImportDeclaration\", node, opts);\n}\n\nfunction isImportDefaultSpecifier(node, opts) {\n  return (0, _is.default)(\"ImportDefaultSpecifier\", node, opts);\n}\n\nfunction isImportNamespaceSpecifier(node, opts) {\n  return (0, _is.default)(\"ImportNamespaceSpecifier\", node, opts);\n}\n\nfunction isImportSpecifier(node, opts) {\n  return (0, _is.default)(\"ImportSpecifier\", node, opts);\n}\n\nfunction isMetaProperty(node, opts) {\n  return (0, _is.default)(\"MetaProperty\", node, opts);\n}\n\nfunction isClassMethod(node, opts) {\n  return (0, _is.default)(\"ClassMethod\", node, opts);\n}\n\nfunction isObjectPattern(node, opts) {\n  return (0, _is.default)(\"ObjectPattern\", node, opts);\n}\n\nfunction isSpreadElement(node, opts) {\n  return (0, _is.default)(\"SpreadElement\", node, opts);\n}\n\nfunction isSuper(node, opts) {\n  return (0, _is.default)(\"Super\", node, opts);\n}\n\nfunction isTaggedTemplateExpression(node, opts) {\n  return (0, _is.default)(\"TaggedTemplateExpression\", node, opts);\n}\n\nfunction isTemplateElement(node, opts) {\n  return (0, _is.default)(\"TemplateElement\", node, opts);\n}\n\nfunction isTemplateLiteral(node, opts) {\n  return (0, _is.default)(\"TemplateLiteral\", node, opts);\n}\n\nfunction isYieldExpression(node, opts) {\n  return (0, _is.default)(\"YieldExpression\", node, opts);\n}\n\nfunction isAnyTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"AnyTypeAnnotation\", node, opts);\n}\n\nfunction isArrayTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"ArrayTypeAnnotation\", node, opts);\n}\n\nfunction isBooleanTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"BooleanTypeAnnotation\", node, opts);\n}\n\nfunction isBooleanLiteralTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"BooleanLiteralTypeAnnotation\", node, opts);\n}\n\nfunction isNullLiteralTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"NullLiteralTypeAnnotation\", node, opts);\n}\n\nfunction isClassImplements(node, opts) {\n  return (0, _is.default)(\"ClassImplements\", node, opts);\n}\n\nfunction isDeclareClass(node, opts) {\n  return (0, _is.default)(\"DeclareClass\", node, opts);\n}\n\nfunction isDeclareFunction(node, opts) {\n  return (0, _is.default)(\"DeclareFunction\", node, opts);\n}\n\nfunction isDeclareInterface(node, opts) {\n  return (0, _is.default)(\"DeclareInterface\", node, opts);\n}\n\nfunction isDeclareModule(node, opts) {\n  return (0, _is.default)(\"DeclareModule\", node, opts);\n}\n\nfunction isDeclareModuleExports(node, opts) {\n  return (0, _is.default)(\"DeclareModuleExports\", node, opts);\n}\n\nfunction isDeclareTypeAlias(node, opts) {\n  return (0, _is.default)(\"DeclareTypeAlias\", node, opts);\n}\n\nfunction isDeclareOpaqueType(node, opts) {\n  return (0, _is.default)(\"DeclareOpaqueType\", node, opts);\n}\n\nfunction isDeclareVariable(node, opts) {\n  return (0, _is.default)(\"DeclareVariable\", node, opts);\n}\n\nfunction isDeclareExportDeclaration(node, opts) {\n  return (0, _is.default)(\"DeclareExportDeclaration\", node, opts);\n}\n\nfunction isDeclareExportAllDeclaration(node, opts) {\n  return (0, _is.default)(\"DeclareExportAllDeclaration\", node, opts);\n}\n\nfunction isDeclaredPredicate(node, opts) {\n  return (0, _is.default)(\"DeclaredPredicate\", node, opts);\n}\n\nfunction isExistsTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"ExistsTypeAnnotation\", node, opts);\n}\n\nfunction isFunctionTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"FunctionTypeAnnotation\", node, opts);\n}\n\nfunction isFunctionTypeParam(node, opts) {\n  return (0, _is.default)(\"FunctionTypeParam\", node, opts);\n}\n\nfunction isGenericTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"GenericTypeAnnotation\", node, opts);\n}\n\nfunction isInferredPredicate(node, opts) {\n  return (0, _is.default)(\"InferredPredicate\", node, opts);\n}\n\nfunction isInterfaceExtends(node, opts) {\n  return (0, _is.default)(\"InterfaceExtends\", node, opts);\n}\n\nfunction isInterfaceDeclaration(node, opts) {\n  return (0, _is.default)(\"InterfaceDeclaration\", node, opts);\n}\n\nfunction isIntersectionTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"IntersectionTypeAnnotation\", node, opts);\n}\n\nfunction isMixedTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"MixedTypeAnnotation\", node, opts);\n}\n\nfunction isEmptyTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"EmptyTypeAnnotation\", node, opts);\n}\n\nfunction isNullableTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"NullableTypeAnnotation\", node, opts);\n}\n\nfunction isNumberLiteralTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"NumberLiteralTypeAnnotation\", node, opts);\n}\n\nfunction isNumberTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"NumberTypeAnnotation\", node, opts);\n}\n\nfunction isObjectTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"ObjectTypeAnnotation\", node, opts);\n}\n\nfunction isObjectTypeCallProperty(node, opts) {\n  return (0, _is.default)(\"ObjectTypeCallProperty\", node, opts);\n}\n\nfunction isObjectTypeIndexer(node, opts) {\n  return (0, _is.default)(\"ObjectTypeIndexer\", node, opts);\n}\n\nfunction isObjectTypeProperty(node, opts) {\n  return (0, _is.default)(\"ObjectTypeProperty\", node, opts);\n}\n\nfunction isObjectTypeSpreadProperty(node, opts) {\n  return (0, _is.default)(\"ObjectTypeSpreadProperty\", node, opts);\n}\n\nfunction isOpaqueType(node, opts) {\n  return (0, _is.default)(\"OpaqueType\", node, opts);\n}\n\nfunction isQualifiedTypeIdentifier(node, opts) {\n  return (0, _is.default)(\"QualifiedTypeIdentifier\", node, opts);\n}\n\nfunction isStringLiteralTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"StringLiteralTypeAnnotation\", node, opts);\n}\n\nfunction isStringTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"StringTypeAnnotation\", node, opts);\n}\n\nfunction isThisTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"ThisTypeAnnotation\", node, opts);\n}\n\nfunction isTupleTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"TupleTypeAnnotation\", node, opts);\n}\n\nfunction isTypeofTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"TypeofTypeAnnotation\", node, opts);\n}\n\nfunction isTypeAlias(node, opts) {\n  return (0, _is.default)(\"TypeAlias\", node, opts);\n}\n\nfunction isTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"TypeAnnotation\", node, opts);\n}\n\nfunction isTypeCastExpression(node, opts) {\n  return (0, _is.default)(\"TypeCastExpression\", node, opts);\n}\n\nfunction isTypeParameter(node, opts) {\n  return (0, _is.default)(\"TypeParameter\", node, opts);\n}\n\nfunction isTypeParameterDeclaration(node, opts) {\n  return (0, _is.default)(\"TypeParameterDeclaration\", node, opts);\n}\n\nfunction isTypeParameterInstantiation(node, opts) {\n  return (0, _is.default)(\"TypeParameterInstantiation\", node, opts);\n}\n\nfunction isUnionTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"UnionTypeAnnotation\", node, opts);\n}\n\nfunction isVariance(node, opts) {\n  return (0, _is.default)(\"Variance\", node, opts);\n}\n\nfunction isVoidTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"VoidTypeAnnotation\", node, opts);\n}\n\nfunction isJSXAttribute(node, opts) {\n  return (0, _is.default)(\"JSXAttribute\", node, opts);\n}\n\nfunction isJSXClosingElement(node, opts) {\n  return (0, _is.default)(\"JSXClosingElement\", node, opts);\n}\n\nfunction isJSXElement(node, opts) {\n  return (0, _is.default)(\"JSXElement\", node, opts);\n}\n\nfunction isJSXEmptyExpression(node, opts) {\n  return (0, _is.default)(\"JSXEmptyExpression\", node, opts);\n}\n\nfunction isJSXExpressionContainer(node, opts) {\n  return (0, _is.default)(\"JSXExpressionContainer\", node, opts);\n}\n\nfunction isJSXSpreadChild(node, opts) {\n  return (0, _is.default)(\"JSXSpreadChild\", node, opts);\n}\n\nfunction isJSXIdentifier(node, opts) {\n  return (0, _is.default)(\"JSXIdentifier\", node, opts);\n}\n\nfunction isJSXMemberExpression(node, opts) {\n  return (0, _is.default)(\"JSXMemberExpression\", node, opts);\n}\n\nfunction isJSXNamespacedName(node, opts) {\n  return (0, _is.default)(\"JSXNamespacedName\", node, opts);\n}\n\nfunction isJSXOpeningElement(node, opts) {\n  return (0, _is.default)(\"JSXOpeningElement\", node, opts);\n}\n\nfunction isJSXSpreadAttribute(node, opts) {\n  return (0, _is.default)(\"JSXSpreadAttribute\", node, opts);\n}\n\nfunction isJSXText(node, opts) {\n  return (0, _is.default)(\"JSXText\", node, opts);\n}\n\nfunction isJSXFragment(node, opts) {\n  return (0, _is.default)(\"JSXFragment\", node, opts);\n}\n\nfunction isJSXOpeningFragment(node, opts) {\n  return (0, _is.default)(\"JSXOpeningFragment\", node, opts);\n}\n\nfunction isJSXClosingFragment(node, opts) {\n  return (0, _is.default)(\"JSXClosingFragment\", node, opts);\n}\n\nfunction isNoop(node, opts) {\n  return (0, _is.default)(\"Noop\", node, opts);\n}\n\nfunction isParenthesizedExpression(node, opts) {\n  return (0, _is.default)(\"ParenthesizedExpression\", node, opts);\n}\n\nfunction isAwaitExpression(node, opts) {\n  return (0, _is.default)(\"AwaitExpression\", node, opts);\n}\n\nfunction isBindExpression(node, opts) {\n  return (0, _is.default)(\"BindExpression\", node, opts);\n}\n\nfunction isClassProperty(node, opts) {\n  return (0, _is.default)(\"ClassProperty\", node, opts);\n}\n\nfunction isOptionalMemberExpression(node, opts) {\n  return (0, _is.default)(\"OptionalMemberExpression\", node, opts);\n}\n\nfunction isOptionalCallExpression(node, opts) {\n  return (0, _is.default)(\"OptionalCallExpression\", node, opts);\n}\n\nfunction isImport(node, opts) {\n  return (0, _is.default)(\"Import\", node, opts);\n}\n\nfunction isDecorator(node, opts) {\n  return (0, _is.default)(\"Decorator\", node, opts);\n}\n\nfunction isDoExpression(node, opts) {\n  return (0, _is.default)(\"DoExpression\", node, opts);\n}\n\nfunction isExportDefaultSpecifier(node, opts) {\n  return (0, _is.default)(\"ExportDefaultSpecifier\", node, opts);\n}\n\nfunction isExportNamespaceSpecifier(node, opts) {\n  return (0, _is.default)(\"ExportNamespaceSpecifier\", node, opts);\n}\n\nfunction isTSParameterProperty(node, opts) {\n  return (0, _is.default)(\"TSParameterProperty\", node, opts);\n}\n\nfunction isTSDeclareFunction(node, opts) {\n  return (0, _is.default)(\"TSDeclareFunction\", node, opts);\n}\n\nfunction isTSDeclareMethod(node, opts) {\n  return (0, _is.default)(\"TSDeclareMethod\", node, opts);\n}\n\nfunction isTSQualifiedName(node, opts) {\n  return (0, _is.default)(\"TSQualifiedName\", node, opts);\n}\n\nfunction isTSCallSignatureDeclaration(node, opts) {\n  return (0, _is.default)(\"TSCallSignatureDeclaration\", node, opts);\n}\n\nfunction isTSConstructSignatureDeclaration(node, opts) {\n  return (0, _is.default)(\"TSConstructSignatureDeclaration\", node, opts);\n}\n\nfunction isTSPropertySignature(node, opts) {\n  return (0, _is.default)(\"TSPropertySignature\", node, opts);\n}\n\nfunction isTSMethodSignature(node, opts) {\n  return (0, _is.default)(\"TSMethodSignature\", node, opts);\n}\n\nfunction isTSIndexSignature(node, opts) {\n  return (0, _is.default)(\"TSIndexSignature\", node, opts);\n}\n\nfunction isTSAnyKeyword(node, opts) {\n  return (0, _is.default)(\"TSAnyKeyword\", node, opts);\n}\n\nfunction isTSNumberKeyword(node, opts) {\n  return (0, _is.default)(\"TSNumberKeyword\", node, opts);\n}\n\nfunction isTSObjectKeyword(node, opts) {\n  return (0, _is.default)(\"TSObjectKeyword\", node, opts);\n}\n\nfunction isTSBooleanKeyword(node, opts) {\n  return (0, _is.default)(\"TSBooleanKeyword\", node, opts);\n}\n\nfunction isTSStringKeyword(node, opts) {\n  return (0, _is.default)(\"TSStringKeyword\", node, opts);\n}\n\nfunction isTSSymbolKeyword(node, opts) {\n  return (0, _is.default)(\"TSSymbolKeyword\", node, opts);\n}\n\nfunction isTSVoidKeyword(node, opts) {\n  return (0, _is.default)(\"TSVoidKeyword\", node, opts);\n}\n\nfunction isTSUndefinedKeyword(node, opts) {\n  return (0, _is.default)(\"TSUndefinedKeyword\", node, opts);\n}\n\nfunction isTSNullKeyword(node, opts) {\n  return (0, _is.default)(\"TSNullKeyword\", node, opts);\n}\n\nfunction isTSNeverKeyword(node, opts) {\n  return (0, _is.default)(\"TSNeverKeyword\", node, opts);\n}\n\nfunction isTSThisType(node, opts) {\n  return (0, _is.default)(\"TSThisType\", node, opts);\n}\n\nfunction isTSFunctionType(node, opts) {\n  return (0, _is.default)(\"TSFunctionType\", node, opts);\n}\n\nfunction isTSConstructorType(node, opts) {\n  return (0, _is.default)(\"TSConstructorType\", node, opts);\n}\n\nfunction isTSTypeReference(node, opts) {\n  return (0, _is.default)(\"TSTypeReference\", node, opts);\n}\n\nfunction isTSTypePredicate(node, opts) {\n  return (0, _is.default)(\"TSTypePredicate\", node, opts);\n}\n\nfunction isTSTypeQuery(node, opts) {\n  return (0, _is.default)(\"TSTypeQuery\", node, opts);\n}\n\nfunction isTSTypeLiteral(node, opts) {\n  return (0, _is.default)(\"TSTypeLiteral\", node, opts);\n}\n\nfunction isTSArrayType(node, opts) {\n  return (0, _is.default)(\"TSArrayType\", node, opts);\n}\n\nfunction isTSTupleType(node, opts) {\n  return (0, _is.default)(\"TSTupleType\", node, opts);\n}\n\nfunction isTSUnionType(node, opts) {\n  return (0, _is.default)(\"TSUnionType\", node, opts);\n}\n\nfunction isTSIntersectionType(node, opts) {\n  return (0, _is.default)(\"TSIntersectionType\", node, opts);\n}\n\nfunction isTSConditionalType(node, opts) {\n  return (0, _is.default)(\"TSConditionalType\", node, opts);\n}\n\nfunction isTSInferType(node, opts) {\n  return (0, _is.default)(\"TSInferType\", node, opts);\n}\n\nfunction isTSParenthesizedType(node, opts) {\n  return (0, _is.default)(\"TSParenthesizedType\", node, opts);\n}\n\nfunction isTSTypeOperator(node, opts) {\n  return (0, _is.default)(\"TSTypeOperator\", node, opts);\n}\n\nfunction isTSIndexedAccessType(node, opts) {\n  return (0, _is.default)(\"TSIndexedAccessType\", node, opts);\n}\n\nfunction isTSMappedType(node, opts) {\n  return (0, _is.default)(\"TSMappedType\", node, opts);\n}\n\nfunction isTSLiteralType(node, opts) {\n  return (0, _is.default)(\"TSLiteralType\", node, opts);\n}\n\nfunction isTSExpressionWithTypeArguments(node, opts) {\n  return (0, _is.default)(\"TSExpressionWithTypeArguments\", node, opts);\n}\n\nfunction isTSInterfaceDeclaration(node, opts) {\n  return (0, _is.default)(\"TSInterfaceDeclaration\", node, opts);\n}\n\nfunction isTSInterfaceBody(node, opts) {\n  return (0, _is.default)(\"TSInterfaceBody\", node, opts);\n}\n\nfunction isTSTypeAliasDeclaration(node, opts) {\n  return (0, _is.default)(\"TSTypeAliasDeclaration\", node, opts);\n}\n\nfunction isTSAsExpression(node, opts) {\n  return (0, _is.default)(\"TSAsExpression\", node, opts);\n}\n\nfunction isTSTypeAssertion(node, opts) {\n  return (0, _is.default)(\"TSTypeAssertion\", node, opts);\n}\n\nfunction isTSEnumDeclaration(node, opts) {\n  return (0, _is.default)(\"TSEnumDeclaration\", node, opts);\n}\n\nfunction isTSEnumMember(node, opts) {\n  return (0, _is.default)(\"TSEnumMember\", node, opts);\n}\n\nfunction isTSModuleDeclaration(node, opts) {\n  return (0, _is.default)(\"TSModuleDeclaration\", node, opts);\n}\n\nfunction isTSModuleBlock(node, opts) {\n  return (0, _is.default)(\"TSModuleBlock\", node, opts);\n}\n\nfunction isTSImportEqualsDeclaration(node, opts) {\n  return (0, _is.default)(\"TSImportEqualsDeclaration\", node, opts);\n}\n\nfunction isTSExternalModuleReference(node, opts) {\n  return (0, _is.default)(\"TSExternalModuleReference\", node, opts);\n}\n\nfunction isTSNonNullExpression(node, opts) {\n  return (0, _is.default)(\"TSNonNullExpression\", node, opts);\n}\n\nfunction isTSExportAssignment(node, opts) {\n  return (0, _is.default)(\"TSExportAssignment\", node, opts);\n}\n\nfunction isTSNamespaceExportDeclaration(node, opts) {\n  return (0, _is.default)(\"TSNamespaceExportDeclaration\", node, opts);\n}\n\nfunction isTSTypeAnnotation(node, opts) {\n  return (0, _is.default)(\"TSTypeAnnotation\", node, opts);\n}\n\nfunction isTSTypeParameterInstantiation(node, opts) {\n  return (0, _is.default)(\"TSTypeParameterInstantiation\", node, opts);\n}\n\nfunction isTSTypeParameterDeclaration(node, opts) {\n  return (0, _is.default)(\"TSTypeParameterDeclaration\", node, opts);\n}\n\nfunction isTSTypeParameter(node, opts) {\n  return (0, _is.default)(\"TSTypeParameter\", node, opts);\n}\n\nfunction isExpression(node, opts) {\n  return (0, _is.default)(\"Expression\", node, opts);\n}\n\nfunction isBinary(node, opts) {\n  return (0, _is.default)(\"Binary\", node, opts);\n}\n\nfunction isScopable(node, opts) {\n  return (0, _is.default)(\"Scopable\", node, opts);\n}\n\nfunction isBlockParent(node, opts) {\n  return (0, _is.default)(\"BlockParent\", node, opts);\n}\n\nfunction isBlock(node, opts) {\n  return (0, _is.default)(\"Block\", node, opts);\n}\n\nfunction isStatement(node, opts) {\n  return (0, _is.default)(\"Statement\", node, opts);\n}\n\nfunction isTerminatorless(node, opts) {\n  return (0, _is.default)(\"Terminatorless\", node, opts);\n}\n\nfunction isCompletionStatement(node, opts) {\n  return (0, _is.default)(\"CompletionStatement\", node, opts);\n}\n\nfunction isConditional(node, opts) {\n  return (0, _is.default)(\"Conditional\", node, opts);\n}\n\nfunction isLoop(node, opts) {\n  return (0, _is.default)(\"Loop\", node, opts);\n}\n\nfunction isWhile(node, opts) {\n  return (0, _is.default)(\"While\", node, opts);\n}\n\nfunction isExpressionWrapper(node, opts) {\n  return (0, _is.default)(\"ExpressionWrapper\", node, opts);\n}\n\nfunction isFor(node, opts) {\n  return (0, _is.default)(\"For\", node, opts);\n}\n\nfunction isForXStatement(node, opts) {\n  return (0, _is.default)(\"ForXStatement\", node, opts);\n}\n\nfunction isFunction(node, opts) {\n  return (0, _is.default)(\"Function\", node, opts);\n}\n\nfunction isFunctionParent(node, opts) {\n  return (0, _is.default)(\"FunctionParent\", node, opts);\n}\n\nfunction isPureish(node, opts) {\n  return (0, _is.default)(\"Pureish\", node, opts);\n}\n\nfunction isDeclaration(node, opts) {\n  return (0, _is.default)(\"Declaration\", node, opts);\n}\n\nfunction isPatternLike(node, opts) {\n  return (0, _is.default)(\"PatternLike\", node, opts);\n}\n\nfunction isLVal(node, opts) {\n  return (0, _is.default)(\"LVal\", node, opts);\n}\n\nfunction isTSEntityName(node, opts) {\n  return (0, _is.default)(\"TSEntityName\", node, opts);\n}\n\nfunction isLiteral(node, opts) {\n  return (0, _is.default)(\"Literal\", node, opts);\n}\n\nfunction isImmutable(node, opts) {\n  return (0, _is.default)(\"Immutable\", node, opts);\n}\n\nfunction isUserWhitespacable(node, opts) {\n  return (0, _is.default)(\"UserWhitespacable\", node, opts);\n}\n\nfunction isMethod(node, opts) {\n  return (0, _is.default)(\"Method\", node, opts);\n}\n\nfunction isObjectMember(node, opts) {\n  return (0, _is.default)(\"ObjectMember\", node, opts);\n}\n\nfunction isProperty(node, opts) {\n  return (0, _is.default)(\"Property\", node, opts);\n}\n\nfunction isUnaryLike(node, opts) {\n  return (0, _is.default)(\"UnaryLike\", node, opts);\n}\n\nfunction isPattern(node, opts) {\n  return (0, _is.default)(\"Pattern\", node, opts);\n}\n\nfunction isClass(node, opts) {\n  return (0, _is.default)(\"Class\", node, opts);\n}\n\nfunction isModuleDeclaration(node, opts) {\n  return (0, _is.default)(\"ModuleDeclaration\", node, opts);\n}\n\nfunction isExportDeclaration(node, opts) {\n  return (0, _is.default)(\"ExportDeclaration\", node, opts);\n}\n\nfunction isModuleSpecifier(node, opts) {\n  return (0, _is.default)(\"ModuleSpecifier\", node, opts);\n}\n\nfunction isFlow(node, opts) {\n  return (0, _is.default)(\"Flow\", node, opts);\n}\n\nfunction isFlowType(node, opts) {\n  return (0, _is.default)(\"FlowType\", node, opts);\n}\n\nfunction isFlowBaseAnnotation(node, opts) {\n  return (0, _is.default)(\"FlowBaseAnnotation\", node, opts);\n}\n\nfunction isFlowDeclaration(node, opts) {\n  return (0, _is.default)(\"FlowDeclaration\", node, opts);\n}\n\nfunction isFlowPredicate(node, opts) {\n  return (0, _is.default)(\"FlowPredicate\", node, opts);\n}\n\nfunction isJSX(node, opts) {\n  return (0, _is.default)(\"JSX\", node, opts);\n}\n\nfunction isTSTypeElement(node, opts) {\n  return (0, _is.default)(\"TSTypeElement\", node, opts);\n}\n\nfunction isTSType(node, opts) {\n  return (0, _is.default)(\"TSType\", node, opts);\n}\n\nfunction isNumberLiteral(node, opts) {\n  console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n  return (0, _is.default)(\"NumberLiteral\", node, opts);\n}\n\nfunction isRegexLiteral(node, opts) {\n  console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n  return (0, _is.default)(\"RegexLiteral\", node, opts);\n}\n\nfunction isRestProperty(node, opts) {\n  console.trace(\"The node type RestProperty has been renamed to RestElement\");\n  return (0, _is.default)(\"RestProperty\", node, opts);\n}\n\nfunction isSpreadProperty(node, opts) {\n  console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n  return (0, _is.default)(\"SpreadProperty\", node, opts);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = is;\n\nvar _shallowEqual = _interopRequireDefault(require(\"../utils/shallowEqual\"));\n\nvar _isType = _interopRequireDefault(require(\"./isType\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction is(type, node, opts) {\n  if (!node) return false;\n  var matches = (0, _isType.default)(node.type, type);\n  if (!matches) return false;\n\n  if (typeof opts === \"undefined\") {\n    return true;\n  } else {\n    return (0, _shallowEqual.default)(node, opts);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = shallowEqual;\n\nfunction shallowEqual(actual, expected) {\n  var keys = Object.keys(expected);\n  var _arr = keys;\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var key = _arr[_i];\n\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isType;\n\nvar _definitions = require(\"../definitions\");\n\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) return true;\n  if (_definitions.ALIAS_KEYS[targetType]) return false;\n  var aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];\n\n  if (aliases) {\n    if (aliases[0] === nodeType) return true;\n\n    for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var alias = _ref;\n      if (nodeType === alias) return true;\n    }\n  }\n\n  return false;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"VISITOR_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _utils.VISITOR_KEYS;\n  }\n});\nObject.defineProperty(exports, \"ALIAS_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _utils.ALIAS_KEYS;\n  }\n});\nObject.defineProperty(exports, \"FLIPPED_ALIAS_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _utils.FLIPPED_ALIAS_KEYS;\n  }\n});\nObject.defineProperty(exports, \"NODE_FIELDS\", {\n  enumerable: true,\n  get: function get() {\n    return _utils.NODE_FIELDS;\n  }\n});\nObject.defineProperty(exports, \"BUILDER_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _utils.BUILDER_KEYS;\n  }\n});\nObject.defineProperty(exports, \"DEPRECATED_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _utils.DEPRECATED_KEYS;\n  }\n});\nexports.TYPES = void 0;\n\nfunction _toFastProperties() {\n  var data = _interopRequireDefault(require(\"to-fast-properties\"));\n\n  _toFastProperties = function _toFastProperties() {\n    return data;\n  };\n\n  return data;\n}\n\nrequire(\"./core\");\n\nrequire(\"./es2015\");\n\nrequire(\"./flow\");\n\nrequire(\"./jsx\");\n\nrequire(\"./misc\");\n\nrequire(\"./experimental\");\n\nrequire(\"./typescript\");\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _toFastProperties().default)(_utils.VISITOR_KEYS);\n(0, _toFastProperties().default)(_utils.ALIAS_KEYS);\n(0, _toFastProperties().default)(_utils.FLIPPED_ALIAS_KEYS);\n(0, _toFastProperties().default)(_utils.NODE_FIELDS);\n(0, _toFastProperties().default)(_utils.BUILDER_KEYS);\n(0, _toFastProperties().default)(_utils.DEPRECATED_KEYS);\nvar TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));\nexports.TYPES = TYPES;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"../validators/isValidIdentifier\"));\n\nvar _constants = require(\"../constants\");\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: []\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"LVal\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: _utils.assertOneOf.apply(void 0, _constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\")))\n    },\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nvar functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"LVal\")))\n  },\n  generator: {\n    default: false,\n    validate: (0, _utils.assertValueType)(\"boolean\")\n  },\n  async: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nvar functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\n\nvar functionDeclarationCommon = _objectSpread({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\n\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: _objectSpread({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"]\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: _objectSpread({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nvar patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: _objectSpread({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)(function (node, key, val) {\n        if (!(0, _isValidIdentifier.default)(val)) {}\n      }, (0, _utils.assertValueType)(\"string\"))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.assertValueType)(\"string\"),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: _utils.assertOneOf.apply(void 0, _constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\"],\n  fields: _objectSpread({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")),\n      default: \"method\"\n    },\n    computed: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    key: {\n      validate: function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", \"decorators\"],\n  fields: {\n    computed: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    key: {\n      validate: function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: _objectSpread({}, patternLikeCommon, {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"LVal\")\n    }\n  })\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: _utils.assertOneOf.apply(void 0, _constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: _utils.assertOneOf.apply(void 0, _constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"var\", \"let\", \"const\"))\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  }\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"LVal\")\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Statement\")\n    }\n  }\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isValidIdentifier;\n\nfunction _esutils() {\n  var data = _interopRequireDefault(require(\"esutils\"));\n\n  _esutils = function _esutils() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isValidIdentifier(name) {\n  if (typeof name !== \"string\" || _esutils().default.keyword.isReservedWordES6(name, true)) {\n    return false;\n  } else if (name === \"await\") {\n    return false;\n  } else {\n    return _esutils().default.keyword.isIdentifierNameES6(name);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;\nvar STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nexports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;\nvar FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nexports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;\nvar FOR_INIT_KEYS = [\"left\", \"init\"];\nexports.FOR_INIT_KEYS = FOR_INIT_KEYS;\nvar COMMENT_KEYS = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\nexports.COMMENT_KEYS = COMMENT_KEYS;\nvar LOGICAL_OPERATORS = [\"||\", \"&&\", \"??\"];\nexports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;\nvar UPDATE_OPERATORS = [\"++\", \"--\"];\nexports.UPDATE_OPERATORS = UPDATE_OPERATORS;\nvar BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nexports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;\nvar EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nexports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;\nvar COMPARISON_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS.concat([\"in\", \"instanceof\"]);\nexports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;\nvar BOOLEAN_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS.concat(BOOLEAN_NUMBER_BINARY_OPERATORS);\nexports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;\nvar NUMBER_BINARY_OPERATORS = [\"-\", \"/\", \"%\", \"*\", \"**\", \"&\", \"|\", \">>\", \">>>\", \"<<\", \"^\"];\nexports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;\nvar BINARY_OPERATORS = [\"+\"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);\nexports.BINARY_OPERATORS = BINARY_OPERATORS;\nvar BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nexports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;\nvar NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"~\"];\nexports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;\nvar STRING_UNARY_OPERATORS = [\"typeof\"];\nexports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;\nvar UNARY_OPERATORS = [\"void\", \"throw\"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);\nexports.UNARY_OPERATORS = UNARY_OPERATORS;\nvar INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"]\n};\nexports.INHERIT_KEYS = INHERIT_KEYS;\nvar BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nexports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;\nvar NOT_LOCAL_BINDING = Symbol.for(\"should not be considered a local binding\");\nexports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validate = validate;\nexports.typeIs = typeIs;\nexports.validateType = validateType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.validateArrayOfType = validateArrayOfType;\nexports.assertEach = assertEach;\nexports.assertOneOf = assertOneOf;\nexports.assertNodeType = assertNodeType;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports.default = defineType;\nexports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;\n\nvar _is = _interopRequireDefault(require(\"../validators/is\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nvar ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nvar FLIPPED_ALIAS_KEYS = {};\nexports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\nvar NODE_FIELDS = {};\nexports.NODE_FIELDS = NODE_FIELDS;\nvar BUILDER_KEYS = {};\nexports.BUILDER_KEYS = BUILDER_KEYS;\nvar DEPRECATED_KEYS = {};\nexports.DEPRECATED_KEYS = DEPRECATED_KEYS;\n\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else if (val === undefined) {\n    return \"undefined\";\n  } else {\n    return typeof val;\n  }\n}\n\nfunction validate(validate) {\n  return {\n    validate: validate\n  };\n}\n\nfunction typeIs(typeName) {\n  return typeof typeName === \"string\" ? assertNodeType(typeName) : assertNodeType.apply(void 0, typeName);\n}\n\nfunction validateType(typeName) {\n  return validate(typeIs(typeName));\n}\n\nfunction validateOptional(validate) {\n  return {\n    validate: validate,\n    optional: true\n  };\n}\n\nfunction validateOptionalType(typeName) {\n  return {\n    validate: typeIs(typeName),\n    optional: true\n  };\n}\n\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nfunction arrayOfType(typeName) {\n  return arrayOf(typeIs(typeName));\n}\n\nfunction validateArrayOfType(typeName) {\n  return validate(arrayOfType(typeName));\n}\n\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n\n    for (var i = 0; i < val.length; i++) {\n      callback(node, key + \"[\" + i + \"]\", val[i]);\n    }\n  }\n\n  validator.each = callback;\n  return validator;\n}\n\nfunction assertOneOf() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  function validate(node, key, val) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(\"Property \" + key + \" expected value to be one of \" + JSON.stringify(values) + \" but got \" + JSON.stringify(val));\n    }\n  }\n\n  validate.oneOf = values;\n  return validate;\n}\n\nfunction assertNodeType() {\n  for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    types[_key2] = arguments[_key2];\n  }\n\n  function validate(node, key, val) {\n    var valid = false;\n\n    for (var _i = 0; _i < types.length; _i++) {\n      var type = types[_i];\n\n      if ((0, _is.default)(type, val)) {\n        valid = true;\n        break;\n      }\n    }\n\n    if (!valid) {\n      throw new TypeError(\"Property \" + key + \" of \" + node.type + \" expected node to be of a type \" + JSON.stringify(types) + \" \" + (\"but instead got \" + JSON.stringify(val && val.type)));\n    }\n  }\n\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\n\nfunction assertNodeOrValueType() {\n  for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    types[_key3] = arguments[_key3];\n  }\n\n  function validate(node, key, val) {\n    var valid = false;\n\n    for (var _i2 = 0; _i2 < types.length; _i2++) {\n      var type = types[_i2];\n\n      if (getType(val) === type || (0, _is.default)(type, val)) {\n        valid = true;\n        break;\n      }\n    }\n\n    if (!valid) {\n      throw new TypeError(\"Property \" + key + \" of \" + node.type + \" expected node to be of a type \" + JSON.stringify(types) + \" \" + (\"but instead got \" + JSON.stringify(val && val.type)));\n    }\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\n\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    var valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\"Property \" + key + \" expected type of \" + type + \" but got \" + getType(val));\n    }\n  }\n\n  validate.type = type;\n  return validate;\n}\n\nfunction chain() {\n  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    fns[_key4] = arguments[_key4];\n  }\n\n  function validate() {\n    for (var _i3 = 0; _i3 < fns.length; _i3++) {\n      var fn = fns[_i3];\n      fn.apply(void 0, arguments);\n    }\n  }\n\n  validate.chainOf = fns;\n  return validate;\n}\n\nfunction defineType(type, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var inherits = opts.inherits && store[opts.inherits] || {};\n  var fields = opts.fields || inherits.fields || {};\n  var visitor = opts.visitor || inherits.visitor || [];\n  var aliases = opts.aliases || inherits.aliases || [];\n  var builder = opts.builder || inherits.builder || opts.visitor || [];\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n\n  var _arr = visitor.concat(builder);\n\n  for (var _i4 = 0; _i4 < _arr.length; _i4++) {\n    var _key5 = _arr[_i4];\n    fields[_key5] = fields[_key5] || {};\n  }\n\n  for (var key in fields) {\n    var field = fields[key];\n\n    if (builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate) {\n      field.validate = assertValueType(getType(field.default));\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(function (alias) {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n  store[type] = opts;\n}\n\nvar store = {};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nvar _core = require(\"./core\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n(0, _utils.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: _objectSpread({}, _core.patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n    }\n  })\n});\n(0, _utils.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: _objectSpread({}, _core.patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n    }\n  })\n});\n(0, _utils.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: _objectSpread({}, _core.functionCommon, _core.functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\n(0, _utils.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\nvar classCommon = {\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  },\n  body: {\n    validate: (0, _utils.assertNodeType)(\"ClassBody\")\n  },\n  superClass: {\n    optional: true,\n    validate: (0, _utils.assertNodeType)(\"Expression\")\n  },\n  superTypeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n    optional: true\n  },\n  implements: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n    optional: true\n  }\n};\n(0, _utils.default)(\"ClassDeclaration\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\", \"Pureish\"],\n  fields: _objectSpread({}, classCommon, {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ClassExpression\", {\n  inherits: \"ClassDeclaration\",\n  aliases: [\"Scopable\", \"Class\", \"Expression\", \"Pureish\"],\n  fields: _objectSpread({}, classCommon, {\n    id: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"Declaration\"),\n      optional: true\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(null, \"type\", \"typeof\")\n    }\n  }\n});\n(0, _utils.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nvar classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  static: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  computed: {\n    default: false,\n    validate: (0, _utils.assertValueType)(\"boolean\")\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      var computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        var validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\n\nvar classMethodOrDeclareMethodCommon = _objectSpread({}, _core.functionCommon, classMethodOrPropertyCommon, {\n  kind: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\")),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\n\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n(0, _utils.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: _objectSpread({}, classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\n(0, _utils.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: _objectSpread({}, _core.patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\n(0, _utils.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {},\n    tail: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  }\n});\n(0, _utils.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});","\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n(0, _utils.default)(\"AnyTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"BooleanTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"BooleanLiteralTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"NullLiteralTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\n(0, _utils.default)(\"DeclareClass\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\"),\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n    mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n    body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n  }\n});\n(0, _utils.default)(\"DeclareFunction\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    predicate: (0, _utils.validateOptionalType)(\"DeclaredPredicate\")\n  }\n});\n(0, _utils.default)(\"DeclareInterface\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    extends: (0, _utils.validateOptionalType)(\"InterfaceExtends\"),\n    mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"Flow\")),\n    body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n  }\n});\n(0, _utils.default)(\"DeclareModule\", {\n  builder: [\"id\", \"body\", \"kind\"],\n  visitor: [\"id\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    body: (0, _utils.validateType)(\"BlockStatement\"),\n    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"CommonJS\", \"ES\"))\n  }\n});\n(0, _utils.default)(\"DeclareModuleExports\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n  }\n});\n(0, _utils.default)(\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    right: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"DeclareOpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    supertype: (0, _utils.validateOptionalType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\n(0, _utils.default)(\"DeclareExportDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    declaration: (0, _utils.validateOptionalType)(\"Flow\"),\n    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)([\"ExportSpecifier\", \"ExportNamespaceSpecifier\"])),\n    source: (0, _utils.validateOptionalType)(\"StringLiteral\"),\n    default: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"DeclareExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    source: (0, _utils.validateType)(\"StringLiteral\"),\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)([\"type\", \"value\"]))\n  }\n});\n(0, _utils.default)(\"DeclaredPredicate\", {\n  visitor: [\"value\"],\n  aliases: [\"Flow\", \"FlowPredicate\"],\n  fields: {\n    value: (0, _utils.validateType)(\"Flow\")\n  }\n});\n(0, _utils.default)(\"ExistsTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\"]\n});\n(0, _utils.default)(\"FunctionTypeAnnotation\", {\n  visitor: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"FunctionTypeParam\")),\n    rest: (0, _utils.validateOptionalType)(\"FunctionTypeParam\"),\n    returnType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  aliases: [\"Flow\"],\n  fields: {\n    name: (0, _utils.validateOptionalType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\n(0, _utils.default)(\"InferredPredicate\", {\n  aliases: [\"Flow\", \"FlowPredicate\"]\n});\n(0, _utils.default)(\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\n(0, _utils.default)(\"InterfaceDeclaration\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    extends: (0, _utils.validate)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n    mixins: (0, _utils.validate)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n    body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n  }\n});\n(0, _utils.default)(\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\n(0, _utils.default)(\"MixedTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"EmptyTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"NumberLiteralTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"number\"))\n  }\n});\n(0, _utils.default)(\"NumberTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  builder: [\"properties\", \"indexers\", \"callProperties\", \"exact\"],\n  fields: {\n    properties: (0, _utils.validate)((0, _utils.arrayOfType)([\"ObjectTypeProperty\", \"ObjectTypeSpreadProperty\"])),\n    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ObjectTypeIndexer\")),\n    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ObjectTypeCallProperty\")),\n    exact: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {\n    value: (0, _utils.validateType)(\"FlowType\"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"ObjectTypeIndexer\", {\n  visitor: [\"id\", \"key\", \"value\", \"variance\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {\n    id: (0, _utils.validateOptionalType)(\"Identifier\"),\n    key: (0, _utils.validateType)(\"FlowType\"),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    variance: (0, _utils.validateOptionalType)(\"Variance\")\n  }\n});\n(0, _utils.default)(\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\", \"variance\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {\n    key: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"init\", \"get\", \"set\")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    variance: (0, _utils.validateOptionalType)(\"Variance\")\n  }\n});\n(0, _utils.default)(\"ObjectTypeSpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"OpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\", \"impltype\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    supertype: (0, _utils.validateOptionalType)(\"FlowType\"),\n    impltype: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"QualifiedTypeIdentifier\", {\n  visitor: [\"id\", \"qualification\"],\n  aliases: [\"Flow\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    qualification: (0, _utils.validateType)([\"Identifier\", \"QualifiedTypeIdentifier\"])\n  }\n});\n(0, _utils.default)(\"StringLiteralTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"string\"))\n  }\n});\n(0, _utils.default)(\"StringTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"ThisTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\n(0, _utils.default)(\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    right: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"TypeAnnotation\", {\n  aliases: [\"Flow\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"Flow\", \"ExpressionWrapper\", \"Expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n  }\n});\n(0, _utils.default)(\"TypeParameter\", {\n  aliases: [\"Flow\"],\n  visitor: [\"bound\", \"default\", \"variance\"],\n  fields: {\n    name: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n    bound: (0, _utils.validateOptionalType)(\"TypeAnnotation\"),\n    default: (0, _utils.validateOptionalType)(\"FlowType\"),\n    variance: (0, _utils.validateOptionalType)(\"Variance\")\n  }\n});\n(0, _utils.default)(\"TypeParameterDeclaration\", {\n  aliases: [\"Flow\"],\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"TypeParameter\"))\n  }\n});\n(0, _utils.default)(\"TypeParameterInstantiation\", {\n  aliases: [\"Flow\"],\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\n(0, _utils.default)(\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\n(0, _utils.default)(\"Variance\", {\n  aliases: [\"Flow\"],\n  builder: [\"kind\"],\n  fields: {\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"minus\", \"plus\"))\n  }\n});\n(0, _utils.default)(\"VoidTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});","\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n(0, _utils.default)(\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXNamespacedName\")\n    },\n    value: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"JSXElement\", \"JSXFragment\", \"StringLiteral\", \"JSXExpressionContainer\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXElement\", {\n  builder: [\"openingElement\", \"closingElement\", \"children\", \"selfClosing\"],\n  visitor: [\"openingElement\", \"children\", \"closingElement\"],\n  aliases: [\"JSX\", \"Immutable\", \"Expression\"],\n  fields: {\n    openingElement: {\n      validate: (0, _utils.assertNodeType)(\"JSXOpeningElement\")\n    },\n    closingElement: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"JSXClosingElement\")\n    },\n    children: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")))\n    }\n  }\n});\n(0, _utils.default)(\"JSXEmptyExpression\", {\n  aliases: [\"JSX\"]\n});\n(0, _utils.default)(\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXSpreadChild\", {\n  visitor: [\"expression\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXIdentifier\", {\n  builder: [\"name\"],\n  aliases: [\"JSX\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  aliases: [\"JSX\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"JSXMemberExpression\", \"JSXIdentifier\")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  aliases: [\"JSX\"],\n  fields: {\n    namespace: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    },\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXOpeningElement\", {\n  builder: [\"name\", \"attributes\", \"selfClosing\"],\n  visitor: [\"name\", \"attributes\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\")\n    },\n    selfClosing: {\n      default: false,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    attributes: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"JSXAttribute\", \"JSXSpreadAttribute\")))\n    }\n  }\n});\n(0, _utils.default)(\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  aliases: [\"JSX\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXText\", {\n  aliases: [\"JSX\", \"Immutable\"],\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXFragment\", {\n  builder: [\"openingFragment\", \"closingFragment\", \"children\"],\n  visitor: [\"openingFragment\", \"children\", \"closingFragment\"],\n  aliases: [\"JSX\", \"Immutable\", \"Expression\"],\n  fields: {\n    openingFragment: {\n      validate: (0, _utils.assertNodeType)(\"JSXOpeningFragment\")\n    },\n    closingFragment: {\n      validate: (0, _utils.assertNodeType)(\"JSXClosingFragment\")\n    },\n    children: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")))\n    }\n  }\n});\n(0, _utils.default)(\"JSXOpeningFragment\", {\n  aliases: [\"JSX\", \"Immutable\"]\n});\n(0, _utils.default)(\"JSXClosingFragment\", {\n  aliases: [\"JSX\", \"Immutable\"]\n});","\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n(0, _utils.default)(\"Noop\", {\n  visitor: []\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});","\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nvar _es = require(\"./es2015\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n(0, _utils.default)(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"BindExpression\", {\n  visitor: [\"object\", \"callee\"],\n  aliases: [\"Expression\"],\n  fields: {}\n});\n(0, _utils.default)(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\"],\n  aliases: [\"Property\"],\n  fields: _objectSpread({}, _es.classMethodOrPropertyCommon, {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  }\n});\n(0, _utils.default)(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\")))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"Import\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"Decorator\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"DoExpression\", {\n  visitor: [\"body\"],\n  aliases: [\"Expression\"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});","\n\nvar _utils = _interopRequireWildcard(require(\"./utils\"));\n\nvar _core = require(\"./core\");\n\nvar _es = require(\"./es2015\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar bool = (0, _utils.assertValueType)(\"boolean\");\nvar tSFunctionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\n(0, _utils.default)(\"TSParameterProperty\", {\n  aliases: [\"LVal\"],\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    parameter: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"AssignmentPattern\")\n    }\n  }\n});\n(0, _utils.default)(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: _objectSpread({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)\n});\n(0, _utils.default)(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: _objectSpread({}, _es.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)\n});\n(0, _utils.default)(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: (0, _utils.validateType)(\"TSEntityName\"),\n    right: (0, _utils.validateType)(\"Identifier\")\n  }\n});\nvar signatureDeclarationCommon = {\n  typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n  parameters: (0, _utils.validateArrayOfType)([\"Identifier\", \"RestElement\"]),\n  typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n};\nvar callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: signatureDeclarationCommon\n};\n(0, _utils.default)(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\n(0, _utils.default)(\"TSConstructSignatureDeclaration\", callConstructSignatureDeclaration);\nvar namedTypeElementCommon = {\n  key: (0, _utils.validateType)(\"Expression\"),\n  computed: (0, _utils.validate)(bool),\n  optional: (0, _utils.validateOptional)(bool)\n};\n(0, _utils.default)(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\", \"initializer\"],\n  fields: _objectSpread({}, namedTypeElementCommon, {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  })\n});\n(0, _utils.default)(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: _objectSpread({}, signatureDeclarationCommon, namedTypeElementCommon)\n});\n(0, _utils.default)(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    parameters: (0, _utils.validateArrayOfType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n  }\n});\nvar tsKeywordTypes = [\"TSAnyKeyword\", \"TSNumberKeyword\", \"TSObjectKeyword\", \"TSBooleanKeyword\", \"TSStringKeyword\", \"TSSymbolKeyword\", \"TSVoidKeyword\", \"TSUndefinedKeyword\", \"TSNullKeyword\", \"TSNeverKeyword\"];\n\nfor (var _i = 0; _i < tsKeywordTypes.length; _i++) {\n  var type = tsKeywordTypes[_i];\n  (0, _utils.default)(type, {\n    aliases: [\"TSType\"],\n    visitor: [],\n    fields: {}\n  });\n}\n\n(0, _utils.default)(\"TSThisType\", {\n  aliases: [\"TSType\"],\n  visitor: [],\n  fields: {}\n});\nvar fnOrCtr = {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameters\", \"typeAnnotation\"],\n  fields: signatureDeclarationCommon\n};\n(0, _utils.default)(\"TSFunctionType\", fnOrCtr);\n(0, _utils.default)(\"TSConstructorType\", fnOrCtr);\n(0, _utils.default)(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeParameters\"],\n  fields: {\n    typeName: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\n(0, _utils.default)(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  fields: {\n    parameterName: (0, _utils.validateType)([\"Identifier\", \"TSThisType\"]),\n    typeAnnotation: (0, _utils.validateType)(\"TSTypeAnnotation\")\n  }\n});\n(0, _utils.default)(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\"],\n  fields: {\n    exprName: (0, _utils.validateType)(\"TSEntityName\")\n  }\n});\n(0, _utils.default)(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\n(0, _utils.default)(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: (0, _utils.validateArrayOfType)(\"TSType\")\n  }\n});\nvar unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: (0, _utils.validateArrayOfType)(\"TSType\")\n  }\n};\n(0, _utils.default)(\"TSUnionType\", unionOrIntersection);\n(0, _utils.default)(\"TSIntersectionType\", unionOrIntersection);\n(0, _utils.default)(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: (0, _utils.validateType)(\"TSType\"),\n    extendsType: (0, _utils.validateType)(\"TSType\"),\n    trueType: (0, _utils.validateType)(\"TSType\"),\n    falseType: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    operator: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"TSType\"),\n    indexType: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\", \"typeAnnotation\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\"),\n    optional: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSLiteralType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: (0, _utils.validateType)([\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\"])\n  }\n});\n(0, _utils.default)(\"TSExpressionWithTypeArguments\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\n(0, _utils.default)(\"TSInterfaceDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\")),\n    body: (0, _utils.validateType)(\"TSInterfaceBody\")\n  }\n});\n(0, _utils.default)(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\n(0, _utils.default)(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSAsExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSTypeAssertion\", {\n  aliases: [\"Expression\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\"),\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSEnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"members\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    const: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    members: (0, _utils.validateArrayOfType)(\"TSEnumMember\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    global: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    body: (0, _utils.validateType)([\"TSModuleBlock\", \"TSModuleDeclaration\"])\n  }\n});\n(0, _utils.default)(\"TSModuleBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  }\n});\n(0, _utils.default)(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: {\n    isExport: (0, _utils.validate)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    moduleReference: (0, _utils.validateType)([\"TSEntityName\", \"TSExternalModuleReference\"])\n  }\n});\n(0, _utils.default)(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"StringLiteral\")\n  }\n});\n(0, _utils.default)(\"TSNonNullExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\n(0, _utils.default)(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TSType\")\n    }\n  }\n});\n(0, _utils.default)(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSType\")))\n    }\n  }\n});\n(0, _utils.default)(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSTypeParameter\")))\n    }\n  }\n});\n(0, _utils.default)(\"TSTypeParameter\", {\n  visitor: [\"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    constraint: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    },\n    default: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    }\n  }\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isCompatTag;\n\nfunction isCompatTag(tagName) {\n  return !!tagName && /^[a-z]/.test(tagName);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = buildChildren;\n\nvar _generated = require(\"../../validators/generated\");\n\nvar _cleanJSXElementLiteralChild = _interopRequireDefault(require(\"../../utils/react/cleanJSXElementLiteralChild\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction buildChildren(node) {\n  var elements = [];\n\n  for (var i = 0; i < node.children.length; i++) {\n    var child = node.children[i];\n\n    if ((0, _generated.isJSXText)(child)) {\n      (0, _cleanJSXElementLiteralChild.default)(child, elements);\n      continue;\n    }\n\n    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;\n    if ((0, _generated.isJSXEmptyExpression)(child)) continue;\n    elements.push(child);\n  }\n\n  return elements;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cleanJSXElementLiteralChild;\n\nvar _generated = require(\"../../builders/generated\");\n\nfunction cleanJSXElementLiteralChild(child, args) {\n  var lines = child.value.split(/\\r\\n|\\n|\\r/);\n  var lastNonEmptyLine = 0;\n\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].match(/[^ \\t]/)) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  var str = \"\";\n\n  for (var _i = 0; _i < lines.length; _i++) {\n    var line = lines[_i];\n    var isFirstLine = _i === 0;\n    var isLastLine = _i === lines.length - 1;\n    var isLastNonEmptyLine = _i === lastNonEmptyLine;\n    var trimmedLine = line.replace(/\\t/g, \" \");\n\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^[ ]+/, \"\");\n    }\n\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/[ ]+$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) args.push((0, _generated.stringLiteral)(str));\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrayExpression = exports.ArrayExpression = ArrayExpression;\nexports.assignmentExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.binaryExpression = exports.BinaryExpression = BinaryExpression;\nexports.directive = exports.Directive = Directive;\nexports.directiveLiteral = exports.DirectiveLiteral = DirectiveLiteral;\nexports.blockStatement = exports.BlockStatement = BlockStatement;\nexports.breakStatement = exports.BreakStatement = BreakStatement;\nexports.callExpression = exports.CallExpression = CallExpression;\nexports.catchClause = exports.CatchClause = CatchClause;\nexports.conditionalExpression = exports.ConditionalExpression = ConditionalExpression;\nexports.continueStatement = exports.ContinueStatement = ContinueStatement;\nexports.debuggerStatement = exports.DebuggerStatement = DebuggerStatement;\nexports.doWhileStatement = exports.DoWhileStatement = DoWhileStatement;\nexports.emptyStatement = exports.EmptyStatement = EmptyStatement;\nexports.expressionStatement = exports.ExpressionStatement = ExpressionStatement;\nexports.file = exports.File = File;\nexports.forInStatement = exports.ForInStatement = ForInStatement;\nexports.forStatement = exports.ForStatement = ForStatement;\nexports.functionDeclaration = exports.FunctionDeclaration = FunctionDeclaration;\nexports.functionExpression = exports.FunctionExpression = FunctionExpression;\nexports.identifier = exports.Identifier = Identifier;\nexports.ifStatement = exports.IfStatement = IfStatement;\nexports.labeledStatement = exports.LabeledStatement = LabeledStatement;\nexports.stringLiteral = exports.StringLiteral = StringLiteral;\nexports.numericLiteral = exports.NumericLiteral = NumericLiteral;\nexports.nullLiteral = exports.NullLiteral = NullLiteral;\nexports.booleanLiteral = exports.BooleanLiteral = BooleanLiteral;\nexports.regExpLiteral = exports.RegExpLiteral = RegExpLiteral;\nexports.logicalExpression = exports.LogicalExpression = LogicalExpression;\nexports.memberExpression = exports.MemberExpression = MemberExpression;\nexports.newExpression = exports.NewExpression = NewExpression;\nexports.program = exports.Program = Program;\nexports.objectExpression = exports.ObjectExpression = ObjectExpression;\nexports.objectMethod = exports.ObjectMethod = ObjectMethod;\nexports.objectProperty = exports.ObjectProperty = ObjectProperty;\nexports.restElement = exports.RestElement = RestElement;\nexports.returnStatement = exports.ReturnStatement = ReturnStatement;\nexports.sequenceExpression = exports.SequenceExpression = SequenceExpression;\nexports.switchCase = exports.SwitchCase = SwitchCase;\nexports.switchStatement = exports.SwitchStatement = SwitchStatement;\nexports.thisExpression = exports.ThisExpression = ThisExpression;\nexports.throwStatement = exports.ThrowStatement = ThrowStatement;\nexports.tryStatement = exports.TryStatement = TryStatement;\nexports.unaryExpression = exports.UnaryExpression = UnaryExpression;\nexports.updateExpression = exports.UpdateExpression = UpdateExpression;\nexports.variableDeclaration = exports.VariableDeclaration = VariableDeclaration;\nexports.variableDeclarator = exports.VariableDeclarator = VariableDeclarator;\nexports.whileStatement = exports.WhileStatement = WhileStatement;\nexports.withStatement = exports.WithStatement = WithStatement;\nexports.assignmentPattern = exports.AssignmentPattern = AssignmentPattern;\nexports.arrayPattern = exports.ArrayPattern = ArrayPattern;\nexports.arrowFunctionExpression = exports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.classBody = exports.ClassBody = ClassBody;\nexports.classDeclaration = exports.ClassDeclaration = ClassDeclaration;\nexports.classExpression = exports.ClassExpression = ClassExpression;\nexports.exportAllDeclaration = exports.ExportAllDeclaration = ExportAllDeclaration;\nexports.exportDefaultDeclaration = exports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.exportNamedDeclaration = exports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.exportSpecifier = exports.ExportSpecifier = ExportSpecifier;\nexports.forOfStatement = exports.ForOfStatement = ForOfStatement;\nexports.importDeclaration = exports.ImportDeclaration = ImportDeclaration;\nexports.importDefaultSpecifier = exports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.importNamespaceSpecifier = exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\nexports.importSpecifier = exports.ImportSpecifier = ImportSpecifier;\nexports.metaProperty = exports.MetaProperty = MetaProperty;\nexports.classMethod = exports.ClassMethod = ClassMethod;\nexports.objectPattern = exports.ObjectPattern = ObjectPattern;\nexports.spreadElement = exports.SpreadElement = SpreadElement;\nexports.super = exports.Super = Super;\nexports.taggedTemplateExpression = exports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.templateElement = exports.TemplateElement = TemplateElement;\nexports.templateLiteral = exports.TemplateLiteral = TemplateLiteral;\nexports.yieldExpression = exports.YieldExpression = YieldExpression;\nexports.anyTypeAnnotation = exports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.arrayTypeAnnotation = exports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.booleanTypeAnnotation = exports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.booleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.nullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.classImplements = exports.ClassImplements = ClassImplements;\nexports.declareClass = exports.DeclareClass = DeclareClass;\nexports.declareFunction = exports.DeclareFunction = DeclareFunction;\nexports.declareInterface = exports.DeclareInterface = DeclareInterface;\nexports.declareModule = exports.DeclareModule = DeclareModule;\nexports.declareModuleExports = exports.DeclareModuleExports = DeclareModuleExports;\nexports.declareTypeAlias = exports.DeclareTypeAlias = DeclareTypeAlias;\nexports.declareOpaqueType = exports.DeclareOpaqueType = DeclareOpaqueType;\nexports.declareVariable = exports.DeclareVariable = DeclareVariable;\nexports.declareExportDeclaration = exports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.declareExportAllDeclaration = exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.declaredPredicate = exports.DeclaredPredicate = DeclaredPredicate;\nexports.existsTypeAnnotation = exports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.functionTypeAnnotation = exports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.functionTypeParam = exports.FunctionTypeParam = FunctionTypeParam;\nexports.genericTypeAnnotation = exports.GenericTypeAnnotation = GenericTypeAnnotation;\nexports.inferredPredicate = exports.InferredPredicate = InferredPredicate;\nexports.interfaceExtends = exports.InterfaceExtends = InterfaceExtends;\nexports.interfaceDeclaration = exports.InterfaceDeclaration = InterfaceDeclaration;\nexports.intersectionTypeAnnotation = exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.mixedTypeAnnotation = exports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.emptyTypeAnnotation = exports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.nullableTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.numberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = NumberLiteralTypeAnnotation;\nexports.numberTypeAnnotation = exports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.objectTypeAnnotation = exports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.objectTypeCallProperty = exports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.objectTypeIndexer = exports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.objectTypeProperty = exports.ObjectTypeProperty = ObjectTypeProperty;\nexports.objectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.opaqueType = exports.OpaqueType = OpaqueType;\nexports.qualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nexports.stringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;\nexports.stringTypeAnnotation = exports.StringTypeAnnotation = StringTypeAnnotation;\nexports.thisTypeAnnotation = exports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.tupleTypeAnnotation = exports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.typeofTypeAnnotation = exports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.typeAlias = exports.TypeAlias = TypeAlias;\nexports.typeAnnotation = exports.TypeAnnotation = TypeAnnotation;\nexports.typeCastExpression = exports.TypeCastExpression = TypeCastExpression;\nexports.typeParameter = exports.TypeParameter = TypeParameter;\nexports.typeParameterDeclaration = exports.TypeParameterDeclaration = TypeParameterDeclaration;\nexports.typeParameterInstantiation = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.unionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.variance = exports.Variance = Variance;\nexports.voidTypeAnnotation = exports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports.jSXAttribute = exports.jsxAttribute = exports.JSXAttribute = JSXAttribute;\nexports.jSXClosingElement = exports.jsxClosingElement = exports.JSXClosingElement = JSXClosingElement;\nexports.jSXElement = exports.jsxElement = exports.JSXElement = JSXElement;\nexports.jSXEmptyExpression = exports.jsxEmptyExpression = exports.JSXEmptyExpression = JSXEmptyExpression;\nexports.jSXExpressionContainer = exports.jsxExpressionContainer = exports.JSXExpressionContainer = JSXExpressionContainer;\nexports.jSXSpreadChild = exports.jsxSpreadChild = exports.JSXSpreadChild = JSXSpreadChild;\nexports.jSXIdentifier = exports.jsxIdentifier = exports.JSXIdentifier = JSXIdentifier;\nexports.jSXMemberExpression = exports.jsxMemberExpression = exports.JSXMemberExpression = JSXMemberExpression;\nexports.jSXNamespacedName = exports.jsxNamespacedName = exports.JSXNamespacedName = JSXNamespacedName;\nexports.jSXOpeningElement = exports.jsxOpeningElement = exports.JSXOpeningElement = JSXOpeningElement;\nexports.jSXSpreadAttribute = exports.jsxSpreadAttribute = exports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.jSXText = exports.jsxText = exports.JSXText = JSXText;\nexports.jSXFragment = exports.jsxFragment = exports.JSXFragment = JSXFragment;\nexports.jSXOpeningFragment = exports.jsxOpeningFragment = exports.JSXOpeningFragment = JSXOpeningFragment;\nexports.jSXClosingFragment = exports.jsxClosingFragment = exports.JSXClosingFragment = JSXClosingFragment;\nexports.noop = exports.Noop = Noop;\nexports.parenthesizedExpression = exports.ParenthesizedExpression = ParenthesizedExpression;\nexports.awaitExpression = exports.AwaitExpression = AwaitExpression;\nexports.bindExpression = exports.BindExpression = BindExpression;\nexports.classProperty = exports.ClassProperty = ClassProperty;\nexports.optionalMemberExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.optionalCallExpression = exports.OptionalCallExpression = OptionalCallExpression;\nexports.import = exports.Import = Import;\nexports.decorator = exports.Decorator = Decorator;\nexports.doExpression = exports.DoExpression = DoExpression;\nexports.exportDefaultSpecifier = exports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.exportNamespaceSpecifier = exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.tSParameterProperty = exports.tsParameterProperty = exports.TSParameterProperty = TSParameterProperty;\nexports.tSDeclareFunction = exports.tsDeclareFunction = exports.TSDeclareFunction = TSDeclareFunction;\nexports.tSDeclareMethod = exports.tsDeclareMethod = exports.TSDeclareMethod = TSDeclareMethod;\nexports.tSQualifiedName = exports.tsQualifiedName = exports.TSQualifiedName = TSQualifiedName;\nexports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.tSPropertySignature = exports.tsPropertySignature = exports.TSPropertySignature = TSPropertySignature;\nexports.tSMethodSignature = exports.tsMethodSignature = exports.TSMethodSignature = TSMethodSignature;\nexports.tSIndexSignature = exports.tsIndexSignature = exports.TSIndexSignature = TSIndexSignature;\nexports.tSAnyKeyword = exports.tsAnyKeyword = exports.TSAnyKeyword = TSAnyKeyword;\nexports.tSNumberKeyword = exports.tsNumberKeyword = exports.TSNumberKeyword = TSNumberKeyword;\nexports.tSObjectKeyword = exports.tsObjectKeyword = exports.TSObjectKeyword = TSObjectKeyword;\nexports.tSBooleanKeyword = exports.tsBooleanKeyword = exports.TSBooleanKeyword = TSBooleanKeyword;\nexports.tSStringKeyword = exports.tsStringKeyword = exports.TSStringKeyword = TSStringKeyword;\nexports.tSSymbolKeyword = exports.tsSymbolKeyword = exports.TSSymbolKeyword = TSSymbolKeyword;\nexports.tSVoidKeyword = exports.tsVoidKeyword = exports.TSVoidKeyword = TSVoidKeyword;\nexports.tSUndefinedKeyword = exports.tsUndefinedKeyword = exports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.tSNullKeyword = exports.tsNullKeyword = exports.TSNullKeyword = TSNullKeyword;\nexports.tSNeverKeyword = exports.tsNeverKeyword = exports.TSNeverKeyword = TSNeverKeyword;\nexports.tSThisType = exports.tsThisType = exports.TSThisType = TSThisType;\nexports.tSFunctionType = exports.tsFunctionType = exports.TSFunctionType = TSFunctionType;\nexports.tSConstructorType = exports.tsConstructorType = exports.TSConstructorType = TSConstructorType;\nexports.tSTypeReference = exports.tsTypeReference = exports.TSTypeReference = TSTypeReference;\nexports.tSTypePredicate = exports.tsTypePredicate = exports.TSTypePredicate = TSTypePredicate;\nexports.tSTypeQuery = exports.tsTypeQuery = exports.TSTypeQuery = TSTypeQuery;\nexports.tSTypeLiteral = exports.tsTypeLiteral = exports.TSTypeLiteral = TSTypeLiteral;\nexports.tSArrayType = exports.tsArrayType = exports.TSArrayType = TSArrayType;\nexports.tSTupleType = exports.tsTupleType = exports.TSTupleType = TSTupleType;\nexports.tSUnionType = exports.tsUnionType = exports.TSUnionType = TSUnionType;\nexports.tSIntersectionType = exports.tsIntersectionType = exports.TSIntersectionType = TSIntersectionType;\nexports.tSConditionalType = exports.tsConditionalType = exports.TSConditionalType = TSConditionalType;\nexports.tSInferType = exports.tsInferType = exports.TSInferType = TSInferType;\nexports.tSParenthesizedType = exports.tsParenthesizedType = exports.TSParenthesizedType = TSParenthesizedType;\nexports.tSTypeOperator = exports.tsTypeOperator = exports.TSTypeOperator = TSTypeOperator;\nexports.tSIndexedAccessType = exports.tsIndexedAccessType = exports.TSIndexedAccessType = TSIndexedAccessType;\nexports.tSMappedType = exports.tsMappedType = exports.TSMappedType = TSMappedType;\nexports.tSLiteralType = exports.tsLiteralType = exports.TSLiteralType = TSLiteralType;\nexports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = exports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.tSInterfaceBody = exports.tsInterfaceBody = exports.TSInterfaceBody = TSInterfaceBody;\nexports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.tSAsExpression = exports.tsAsExpression = exports.TSAsExpression = TSAsExpression;\nexports.tSTypeAssertion = exports.tsTypeAssertion = exports.TSTypeAssertion = TSTypeAssertion;\nexports.tSEnumDeclaration = exports.tsEnumDeclaration = exports.TSEnumDeclaration = TSEnumDeclaration;\nexports.tSEnumMember = exports.tsEnumMember = exports.TSEnumMember = TSEnumMember;\nexports.tSModuleDeclaration = exports.tsModuleDeclaration = exports.TSModuleDeclaration = TSModuleDeclaration;\nexports.tSModuleBlock = exports.tsModuleBlock = exports.TSModuleBlock = TSModuleBlock;\nexports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.tSExternalModuleReference = exports.tsExternalModuleReference = exports.TSExternalModuleReference = TSExternalModuleReference;\nexports.tSNonNullExpression = exports.tsNonNullExpression = exports.TSNonNullExpression = TSNonNullExpression;\nexports.tSExportAssignment = exports.tsExportAssignment = exports.TSExportAssignment = TSExportAssignment;\nexports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.tSTypeAnnotation = exports.tsTypeAnnotation = exports.TSTypeAnnotation = TSTypeAnnotation;\nexports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = exports.TSTypeParameterDeclaration = TSTypeParameterDeclaration;\nexports.tSTypeParameter = exports.tsTypeParameter = exports.TSTypeParameter = TSTypeParameter;\nexports.numberLiteral = exports.NumberLiteral = NumberLiteral;\nexports.regexLiteral = exports.RegexLiteral = RegexLiteral;\nexports.restProperty = exports.RestProperty = RestProperty;\nexports.spreadProperty = exports.SpreadProperty = SpreadProperty;\n\nvar _builder = _interopRequireDefault(require(\"../builder\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ArrayExpression() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _builder.default.apply(void 0, [\"ArrayExpression\"].concat(args));\n}\n\nfunction AssignmentExpression() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return _builder.default.apply(void 0, [\"AssignmentExpression\"].concat(args));\n}\n\nfunction BinaryExpression() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return _builder.default.apply(void 0, [\"BinaryExpression\"].concat(args));\n}\n\nfunction Directive() {\n  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  return _builder.default.apply(void 0, [\"Directive\"].concat(args));\n}\n\nfunction DirectiveLiteral() {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n\n  return _builder.default.apply(void 0, [\"DirectiveLiteral\"].concat(args));\n}\n\nfunction BlockStatement() {\n  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    args[_key6] = arguments[_key6];\n  }\n\n  return _builder.default.apply(void 0, [\"BlockStatement\"].concat(args));\n}\n\nfunction BreakStatement() {\n  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    args[_key7] = arguments[_key7];\n  }\n\n  return _builder.default.apply(void 0, [\"BreakStatement\"].concat(args));\n}\n\nfunction CallExpression() {\n  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    args[_key8] = arguments[_key8];\n  }\n\n  return _builder.default.apply(void 0, [\"CallExpression\"].concat(args));\n}\n\nfunction CatchClause() {\n  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    args[_key9] = arguments[_key9];\n  }\n\n  return _builder.default.apply(void 0, [\"CatchClause\"].concat(args));\n}\n\nfunction ConditionalExpression() {\n  for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    args[_key10] = arguments[_key10];\n  }\n\n  return _builder.default.apply(void 0, [\"ConditionalExpression\"].concat(args));\n}\n\nfunction ContinueStatement() {\n  for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n    args[_key11] = arguments[_key11];\n  }\n\n  return _builder.default.apply(void 0, [\"ContinueStatement\"].concat(args));\n}\n\nfunction DebuggerStatement() {\n  for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    args[_key12] = arguments[_key12];\n  }\n\n  return _builder.default.apply(void 0, [\"DebuggerStatement\"].concat(args));\n}\n\nfunction DoWhileStatement() {\n  for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n    args[_key13] = arguments[_key13];\n  }\n\n  return _builder.default.apply(void 0, [\"DoWhileStatement\"].concat(args));\n}\n\nfunction EmptyStatement() {\n  for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n    args[_key14] = arguments[_key14];\n  }\n\n  return _builder.default.apply(void 0, [\"EmptyStatement\"].concat(args));\n}\n\nfunction ExpressionStatement() {\n  for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n    args[_key15] = arguments[_key15];\n  }\n\n  return _builder.default.apply(void 0, [\"ExpressionStatement\"].concat(args));\n}\n\nfunction File() {\n  for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n    args[_key16] = arguments[_key16];\n  }\n\n  return _builder.default.apply(void 0, [\"File\"].concat(args));\n}\n\nfunction ForInStatement() {\n  for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n    args[_key17] = arguments[_key17];\n  }\n\n  return _builder.default.apply(void 0, [\"ForInStatement\"].concat(args));\n}\n\nfunction ForStatement() {\n  for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n    args[_key18] = arguments[_key18];\n  }\n\n  return _builder.default.apply(void 0, [\"ForStatement\"].concat(args));\n}\n\nfunction FunctionDeclaration() {\n  for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n    args[_key19] = arguments[_key19];\n  }\n\n  return _builder.default.apply(void 0, [\"FunctionDeclaration\"].concat(args));\n}\n\nfunction FunctionExpression() {\n  for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n    args[_key20] = arguments[_key20];\n  }\n\n  return _builder.default.apply(void 0, [\"FunctionExpression\"].concat(args));\n}\n\nfunction Identifier() {\n  for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n    args[_key21] = arguments[_key21];\n  }\n\n  return _builder.default.apply(void 0, [\"Identifier\"].concat(args));\n}\n\nfunction IfStatement() {\n  for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n    args[_key22] = arguments[_key22];\n  }\n\n  return _builder.default.apply(void 0, [\"IfStatement\"].concat(args));\n}\n\nfunction LabeledStatement() {\n  for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n    args[_key23] = arguments[_key23];\n  }\n\n  return _builder.default.apply(void 0, [\"LabeledStatement\"].concat(args));\n}\n\nfunction StringLiteral() {\n  for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n    args[_key24] = arguments[_key24];\n  }\n\n  return _builder.default.apply(void 0, [\"StringLiteral\"].concat(args));\n}\n\nfunction NumericLiteral() {\n  for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n    args[_key25] = arguments[_key25];\n  }\n\n  return _builder.default.apply(void 0, [\"NumericLiteral\"].concat(args));\n}\n\nfunction NullLiteral() {\n  for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n    args[_key26] = arguments[_key26];\n  }\n\n  return _builder.default.apply(void 0, [\"NullLiteral\"].concat(args));\n}\n\nfunction BooleanLiteral() {\n  for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n    args[_key27] = arguments[_key27];\n  }\n\n  return _builder.default.apply(void 0, [\"BooleanLiteral\"].concat(args));\n}\n\nfunction RegExpLiteral() {\n  for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n    args[_key28] = arguments[_key28];\n  }\n\n  return _builder.default.apply(void 0, [\"RegExpLiteral\"].concat(args));\n}\n\nfunction LogicalExpression() {\n  for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n    args[_key29] = arguments[_key29];\n  }\n\n  return _builder.default.apply(void 0, [\"LogicalExpression\"].concat(args));\n}\n\nfunction MemberExpression() {\n  for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {\n    args[_key30] = arguments[_key30];\n  }\n\n  return _builder.default.apply(void 0, [\"MemberExpression\"].concat(args));\n}\n\nfunction NewExpression() {\n  for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {\n    args[_key31] = arguments[_key31];\n  }\n\n  return _builder.default.apply(void 0, [\"NewExpression\"].concat(args));\n}\n\nfunction Program() {\n  for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {\n    args[_key32] = arguments[_key32];\n  }\n\n  return _builder.default.apply(void 0, [\"Program\"].concat(args));\n}\n\nfunction ObjectExpression() {\n  for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {\n    args[_key33] = arguments[_key33];\n  }\n\n  return _builder.default.apply(void 0, [\"ObjectExpression\"].concat(args));\n}\n\nfunction ObjectMethod() {\n  for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {\n    args[_key34] = arguments[_key34];\n  }\n\n  return _builder.default.apply(void 0, [\"ObjectMethod\"].concat(args));\n}\n\nfunction ObjectProperty() {\n  for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {\n    args[_key35] = arguments[_key35];\n  }\n\n  return _builder.default.apply(void 0, [\"ObjectProperty\"].concat(args));\n}\n\nfunction RestElement() {\n  for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {\n    args[_key36] = arguments[_key36];\n  }\n\n  return _builder.default.apply(void 0, [\"RestElement\"].concat(args));\n}\n\nfunction ReturnStatement() {\n  for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {\n    args[_key37] = arguments[_key37];\n  }\n\n  return _builder.default.apply(void 0, [\"ReturnStatement\"].concat(args));\n}\n\nfunction SequenceExpression() {\n  for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {\n    args[_key38] = arguments[_key38];\n  }\n\n  return _builder.default.apply(void 0, [\"SequenceExpression\"].concat(args));\n}\n\nfunction SwitchCase() {\n  for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {\n    args[_key39] = arguments[_key39];\n  }\n\n  return _builder.default.apply(void 0, [\"SwitchCase\"].concat(args));\n}\n\nfunction SwitchStatement() {\n  for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {\n    args[_key40] = arguments[_key40];\n  }\n\n  return _builder.default.apply(void 0, [\"SwitchStatement\"].concat(args));\n}\n\nfunction ThisExpression() {\n  for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {\n    args[_key41] = arguments[_key41];\n  }\n\n  return _builder.default.apply(void 0, [\"ThisExpression\"].concat(args));\n}\n\nfunction ThrowStatement() {\n  for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {\n    args[_key42] = arguments[_key42];\n  }\n\n  return _builder.default.apply(void 0, [\"ThrowStatement\"].concat(args));\n}\n\nfunction TryStatement() {\n  for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {\n    args[_key43] = arguments[_key43];\n  }\n\n  return _builder.default.apply(void 0, [\"TryStatement\"].concat(args));\n}\n\nfunction UnaryExpression() {\n  for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {\n    args[_key44] = arguments[_key44];\n  }\n\n  return _builder.default.apply(void 0, [\"UnaryExpression\"].concat(args));\n}\n\nfunction UpdateExpression() {\n  for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {\n    args[_key45] = arguments[_key45];\n  }\n\n  return _builder.default.apply(void 0, [\"UpdateExpression\"].concat(args));\n}\n\nfunction VariableDeclaration() {\n  for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {\n    args[_key46] = arguments[_key46];\n  }\n\n  return _builder.default.apply(void 0, [\"VariableDeclaration\"].concat(args));\n}\n\nfunction VariableDeclarator() {\n  for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {\n    args[_key47] = arguments[_key47];\n  }\n\n  return _builder.default.apply(void 0, [\"VariableDeclarator\"].concat(args));\n}\n\nfunction WhileStatement() {\n  for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {\n    args[_key48] = arguments[_key48];\n  }\n\n  return _builder.default.apply(void 0, [\"WhileStatement\"].concat(args));\n}\n\nfunction WithStatement() {\n  for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {\n    args[_key49] = arguments[_key49];\n  }\n\n  return _builder.default.apply(void 0, [\"WithStatement\"].concat(args));\n}\n\nfunction AssignmentPattern() {\n  for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {\n    args[_key50] = arguments[_key50];\n  }\n\n  return _builder.default.apply(void 0, [\"AssignmentPattern\"].concat(args));\n}\n\nfunction ArrayPattern() {\n  for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {\n    args[_key51] = arguments[_key51];\n  }\n\n  return _builder.default.apply(void 0, [\"ArrayPattern\"].concat(args));\n}\n\nfunction ArrowFunctionExpression() {\n  for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {\n    args[_key52] = arguments[_key52];\n  }\n\n  return _builder.default.apply(void 0, [\"ArrowFunctionExpression\"].concat(args));\n}\n\nfunction ClassBody() {\n  for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {\n    args[_key53] = arguments[_key53];\n  }\n\n  return _builder.default.apply(void 0, [\"ClassBody\"].concat(args));\n}\n\nfunction ClassDeclaration() {\n  for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {\n    args[_key54] = arguments[_key54];\n  }\n\n  return _builder.default.apply(void 0, [\"ClassDeclaration\"].concat(args));\n}\n\nfunction ClassExpression() {\n  for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {\n    args[_key55] = arguments[_key55];\n  }\n\n  return _builder.default.apply(void 0, [\"ClassExpression\"].concat(args));\n}\n\nfunction ExportAllDeclaration() {\n  for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {\n    args[_key56] = arguments[_key56];\n  }\n\n  return _builder.default.apply(void 0, [\"ExportAllDeclaration\"].concat(args));\n}\n\nfunction ExportDefaultDeclaration() {\n  for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {\n    args[_key57] = arguments[_key57];\n  }\n\n  return _builder.default.apply(void 0, [\"ExportDefaultDeclaration\"].concat(args));\n}\n\nfunction ExportNamedDeclaration() {\n  for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {\n    args[_key58] = arguments[_key58];\n  }\n\n  return _builder.default.apply(void 0, [\"ExportNamedDeclaration\"].concat(args));\n}\n\nfunction ExportSpecifier() {\n  for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {\n    args[_key59] = arguments[_key59];\n  }\n\n  return _builder.default.apply(void 0, [\"ExportSpecifier\"].concat(args));\n}\n\nfunction ForOfStatement() {\n  for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {\n    args[_key60] = arguments[_key60];\n  }\n\n  return _builder.default.apply(void 0, [\"ForOfStatement\"].concat(args));\n}\n\nfunction ImportDeclaration() {\n  for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {\n    args[_key61] = arguments[_key61];\n  }\n\n  return _builder.default.apply(void 0, [\"ImportDeclaration\"].concat(args));\n}\n\nfunction ImportDefaultSpecifier() {\n  for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {\n    args[_key62] = arguments[_key62];\n  }\n\n  return _builder.default.apply(void 0, [\"ImportDefaultSpecifier\"].concat(args));\n}\n\nfunction ImportNamespaceSpecifier() {\n  for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {\n    args[_key63] = arguments[_key63];\n  }\n\n  return _builder.default.apply(void 0, [\"ImportNamespaceSpecifier\"].concat(args));\n}\n\nfunction ImportSpecifier() {\n  for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {\n    args[_key64] = arguments[_key64];\n  }\n\n  return _builder.default.apply(void 0, [\"ImportSpecifier\"].concat(args));\n}\n\nfunction MetaProperty() {\n  for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {\n    args[_key65] = arguments[_key65];\n  }\n\n  return _builder.default.apply(void 0, [\"MetaProperty\"].concat(args));\n}\n\nfunction ClassMethod() {\n  for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {\n    args[_key66] = arguments[_key66];\n  }\n\n  return _builder.default.apply(void 0, [\"ClassMethod\"].concat(args));\n}\n\nfunction ObjectPattern() {\n  for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {\n    args[_key67] = arguments[_key67];\n  }\n\n  return _builder.default.apply(void 0, [\"ObjectPattern\"].concat(args));\n}\n\nfunction SpreadElement() {\n  for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {\n    args[_key68] = arguments[_key68];\n  }\n\n  return _builder.default.apply(void 0, [\"SpreadElement\"].concat(args));\n}\n\nfunction Super() {\n  for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {\n    args[_key69] = arguments[_key69];\n  }\n\n  return _builder.default.apply(void 0, [\"Super\"].concat(args));\n}\n\nfunction TaggedTemplateExpression() {\n  for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {\n    args[_key70] = arguments[_key70];\n  }\n\n  return _builder.default.apply(void 0, [\"TaggedTemplateExpression\"].concat(args));\n}\n\nfunction TemplateElement() {\n  for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {\n    args[_key71] = arguments[_key71];\n  }\n\n  return _builder.default.apply(void 0, [\"TemplateElement\"].concat(args));\n}\n\nfunction TemplateLiteral() {\n  for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {\n    args[_key72] = arguments[_key72];\n  }\n\n  return _builder.default.apply(void 0, [\"TemplateLiteral\"].concat(args));\n}\n\nfunction YieldExpression() {\n  for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {\n    args[_key73] = arguments[_key73];\n  }\n\n  return _builder.default.apply(void 0, [\"YieldExpression\"].concat(args));\n}\n\nfunction AnyTypeAnnotation() {\n  for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {\n    args[_key74] = arguments[_key74];\n  }\n\n  return _builder.default.apply(void 0, [\"AnyTypeAnnotation\"].concat(args));\n}\n\nfunction ArrayTypeAnnotation() {\n  for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {\n    args[_key75] = arguments[_key75];\n  }\n\n  return _builder.default.apply(void 0, [\"ArrayTypeAnnotation\"].concat(args));\n}\n\nfunction BooleanTypeAnnotation() {\n  for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {\n    args[_key76] = arguments[_key76];\n  }\n\n  return _builder.default.apply(void 0, [\"BooleanTypeAnnotation\"].concat(args));\n}\n\nfunction BooleanLiteralTypeAnnotation() {\n  for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {\n    args[_key77] = arguments[_key77];\n  }\n\n  return _builder.default.apply(void 0, [\"BooleanLiteralTypeAnnotation\"].concat(args));\n}\n\nfunction NullLiteralTypeAnnotation() {\n  for (var _len78 = arguments.length, args = new Array(_len78), _key78 = 0; _key78 < _len78; _key78++) {\n    args[_key78] = arguments[_key78];\n  }\n\n  return _builder.default.apply(void 0, [\"NullLiteralTypeAnnotation\"].concat(args));\n}\n\nfunction ClassImplements() {\n  for (var _len79 = arguments.length, args = new Array(_len79), _key79 = 0; _key79 < _len79; _key79++) {\n    args[_key79] = arguments[_key79];\n  }\n\n  return _builder.default.apply(void 0, [\"ClassImplements\"].concat(args));\n}\n\nfunction DeclareClass() {\n  for (var _len80 = arguments.length, args = new Array(_len80), _key80 = 0; _key80 < _len80; _key80++) {\n    args[_key80] = arguments[_key80];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareClass\"].concat(args));\n}\n\nfunction DeclareFunction() {\n  for (var _len81 = arguments.length, args = new Array(_len81), _key81 = 0; _key81 < _len81; _key81++) {\n    args[_key81] = arguments[_key81];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareFunction\"].concat(args));\n}\n\nfunction DeclareInterface() {\n  for (var _len82 = arguments.length, args = new Array(_len82), _key82 = 0; _key82 < _len82; _key82++) {\n    args[_key82] = arguments[_key82];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareInterface\"].concat(args));\n}\n\nfunction DeclareModule() {\n  for (var _len83 = arguments.length, args = new Array(_len83), _key83 = 0; _key83 < _len83; _key83++) {\n    args[_key83] = arguments[_key83];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareModule\"].concat(args));\n}\n\nfunction DeclareModuleExports() {\n  for (var _len84 = arguments.length, args = new Array(_len84), _key84 = 0; _key84 < _len84; _key84++) {\n    args[_key84] = arguments[_key84];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareModuleExports\"].concat(args));\n}\n\nfunction DeclareTypeAlias() {\n  for (var _len85 = arguments.length, args = new Array(_len85), _key85 = 0; _key85 < _len85; _key85++) {\n    args[_key85] = arguments[_key85];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareTypeAlias\"].concat(args));\n}\n\nfunction DeclareOpaqueType() {\n  for (var _len86 = arguments.length, args = new Array(_len86), _key86 = 0; _key86 < _len86; _key86++) {\n    args[_key86] = arguments[_key86];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareOpaqueType\"].concat(args));\n}\n\nfunction DeclareVariable() {\n  for (var _len87 = arguments.length, args = new Array(_len87), _key87 = 0; _key87 < _len87; _key87++) {\n    args[_key87] = arguments[_key87];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareVariable\"].concat(args));\n}\n\nfunction DeclareExportDeclaration() {\n  for (var _len88 = arguments.length, args = new Array(_len88), _key88 = 0; _key88 < _len88; _key88++) {\n    args[_key88] = arguments[_key88];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareExportDeclaration\"].concat(args));\n}\n\nfunction DeclareExportAllDeclaration() {\n  for (var _len89 = arguments.length, args = new Array(_len89), _key89 = 0; _key89 < _len89; _key89++) {\n    args[_key89] = arguments[_key89];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclareExportAllDeclaration\"].concat(args));\n}\n\nfunction DeclaredPredicate() {\n  for (var _len90 = arguments.length, args = new Array(_len90), _key90 = 0; _key90 < _len90; _key90++) {\n    args[_key90] = arguments[_key90];\n  }\n\n  return _builder.default.apply(void 0, [\"DeclaredPredicate\"].concat(args));\n}\n\nfunction ExistsTypeAnnotation() {\n  for (var _len91 = arguments.length, args = new Array(_len91), _key91 = 0; _key91 < _len91; _key91++) {\n    args[_key91] = arguments[_key91];\n  }\n\n  return _builder.default.apply(void 0, [\"ExistsTypeAnnotation\"].concat(args));\n}\n\nfunction FunctionTypeAnnotation() {\n  for (var _len92 = arguments.length, args = new Array(_len92), _key92 = 0; _key92 < _len92; _key92++) {\n    args[_key92] = arguments[_key92];\n  }\n\n  return _builder.default.apply(void 0, [\"FunctionTypeAnnotation\"].concat(args));\n}\n\nfunction FunctionTypeParam() {\n  for (var _len93 = arguments.length, args = new Array(_len93), _key93 = 0; _key93 < _len93; _key93++) {\n    args[_key93] = arguments[_key93];\n  }\n\n  return _builder.default.apply(void 0, [\"FunctionTypeParam\"].concat(args));\n}\n\nfunction GenericTypeAnnotation() {\n  for (var _len94 = arguments.length, args = new Array(_len94), _key94 = 0; _key94 < _len94; _key94++) {\n    args[_key94] = arguments[_key94];\n  }\n\n  return _builder.default.apply(void 0, [\"GenericTypeAnnotation\"].concat(args));\n}\n\nfunction InferredPredicate() {\n  for (var _len95 = arguments.length, args = new Array(_len95), _key95 = 0; _key95 < _len95; _key95++) {\n    args[_key95] = arguments[_key95];\n  }\n\n  return _builder.default.apply(void 0, [\"InferredPredicate\"].concat(args));\n}\n\nfunction InterfaceExtends() {\n  for (var _len96 = arguments.length, args = new Array(_len96), _key96 = 0; _key96 < _len96; _key96++) {\n    args[_key96] = arguments[_key96];\n  }\n\n  return _builder.default.apply(void 0, [\"InterfaceExtends\"].concat(args));\n}\n\nfunction InterfaceDeclaration() {\n  for (var _len97 = arguments.length, args = new Array(_len97), _key97 = 0; _key97 < _len97; _key97++) {\n    args[_key97] = arguments[_key97];\n  }\n\n  return _builder.default.apply(void 0, [\"InterfaceDeclaration\"].concat(args));\n}\n\nfunction IntersectionTypeAnnotation() {\n  for (var _len98 = arguments.length, args = new Array(_len98), _key98 = 0; _key98 < _len98; _key98++) {\n    args[_key98] = arguments[_key98];\n  }\n\n  return _builder.default.apply(void 0, [\"IntersectionTypeAnnotation\"].concat(args));\n}\n\nfunction MixedTypeAnnotation() {\n  for (var _len99 = arguments.length, args = new Array(_len99), _key99 = 0; _key99 < _len99; _key99++) {\n    args[_key99] = arguments[_key99];\n  }\n\n  return _builder.default.apply(void 0, [\"MixedTypeAnnotation\"].concat(args));\n}\n\nfunction EmptyTypeAnnotation() {\n  for (var _len100 = arguments.length, args = new Array(_len100), _key100 = 0; _key100 < _len100; _key100++) {\n    args[_key100] = arguments[_key100];\n  }\n\n  return _builder.default.apply(void 0, [\"EmptyTypeAnnotation\"].concat(args));\n}\n\nfunction NullableTypeAnnotation() {\n  for (var _len101 = arguments.length, args = new Array(_len101), _key101 = 0; _key101 < _len101; _key101++) {\n    args[_key101] = arguments[_key101];\n  }\n\n  return _builder.default.apply(void 0, [\"NullableTypeAnnotation\"].concat(args));\n}\n\nfunction NumberLiteralTypeAnnotation() {\n  for (var _len102 = arguments.length, args = new Array(_len102), _key102 = 0; _key102 < _len102; _key102++) {\n    args[_key102] = arguments[_key102];\n  }\n\n  return _builder.default.apply(void 0, [\"NumberLiteralTypeAnnotation\"].concat(args));\n}\n\nfunction NumberTypeAnnotation() {\n  for (var _len103 = arguments.length, args = new Array(_len103), _key103 = 0; _key103 < _len103; _key103++) {\n    args[_key103] = arguments[_key103];\n  }\n\n  return _builder.default.apply(void 0, [\"NumberTypeAnnotation\"].concat(args));\n}\n\nfunction ObjectTypeAnnotation() {\n  for (var _len104 = arguments.length, args = new Array(_len104), _key104 = 0; _key104 < _len104; _key104++) {\n    args[_key104] = arguments[_key104];\n  }\n\n  return _builder.default.apply(void 0, [\"ObjectTypeAnnotation\"].concat(args));\n}\n\nfunction ObjectTypeCallProperty() {\n  for (var _len105 = arguments.length, args = new Array(_len105), _key105 = 0; _key105 < _len105; _key105++) {\n    args[_key105] = arguments[_key105];\n  }\n\n  return _builder.default.apply(void 0, [\"ObjectTypeCallProperty\"].concat(args));\n}\n\nfunction ObjectTypeIndexer() {\n  for (var _len106 = arguments.length, args = new Array(_len106), _key106 = 0; _key106 < _len106; _key106++) {\n    args[_key106] = arguments[_key106];\n  }\n\n  return _builder.default.apply(void 0, [\"ObjectTypeIndexer\"].concat(args));\n}\n\nfunction ObjectTypeProperty() {\n  for (var _len107 = arguments.length, args = new Array(_len107), _key107 = 0; _key107 < _len107; _key107++) {\n    args[_key107] = arguments[_key107];\n  }\n\n  return _builder.default.apply(void 0, [\"ObjectTypeProperty\"].concat(args));\n}\n\nfunction ObjectTypeSpreadProperty() {\n  for (var _len108 = arguments.length, args = new Array(_len108), _key108 = 0; _key108 < _len108; _key108++) {\n    args[_key108] = arguments[_key108];\n  }\n\n  return _builder.default.apply(void 0, [\"ObjectTypeSpreadProperty\"].concat(args));\n}\n\nfunction OpaqueType() {\n  for (var _len109 = arguments.length, args = new Array(_len109), _key109 = 0; _key109 < _len109; _key109++) {\n    args[_key109] = arguments[_key109];\n  }\n\n  return _builder.default.apply(void 0, [\"OpaqueType\"].concat(args));\n}\n\nfunction QualifiedTypeIdentifier() {\n  for (var _len110 = arguments.length, args = new Array(_len110), _key110 = 0; _key110 < _len110; _key110++) {\n    args[_key110] = arguments[_key110];\n  }\n\n  return _builder.default.apply(void 0, [\"QualifiedTypeIdentifier\"].concat(args));\n}\n\nfunction StringLiteralTypeAnnotation() {\n  for (var _len111 = arguments.length, args = new Array(_len111), _key111 = 0; _key111 < _len111; _key111++) {\n    args[_key111] = arguments[_key111];\n  }\n\n  return _builder.default.apply(void 0, [\"StringLiteralTypeAnnotation\"].concat(args));\n}\n\nfunction StringTypeAnnotation() {\n  for (var _len112 = arguments.length, args = new Array(_len112), _key112 = 0; _key112 < _len112; _key112++) {\n    args[_key112] = arguments[_key112];\n  }\n\n  return _builder.default.apply(void 0, [\"StringTypeAnnotation\"].concat(args));\n}\n\nfunction ThisTypeAnnotation() {\n  for (var _len113 = arguments.length, args = new Array(_len113), _key113 = 0; _key113 < _len113; _key113++) {\n    args[_key113] = arguments[_key113];\n  }\n\n  return _builder.default.apply(void 0, [\"ThisTypeAnnotation\"].concat(args));\n}\n\nfunction TupleTypeAnnotation() {\n  for (var _len114 = arguments.length, args = new Array(_len114), _key114 = 0; _key114 < _len114; _key114++) {\n    args[_key114] = arguments[_key114];\n  }\n\n  return _builder.default.apply(void 0, [\"TupleTypeAnnotation\"].concat(args));\n}\n\nfunction TypeofTypeAnnotation() {\n  for (var _len115 = arguments.length, args = new Array(_len115), _key115 = 0; _key115 < _len115; _key115++) {\n    args[_key115] = arguments[_key115];\n  }\n\n  return _builder.default.apply(void 0, [\"TypeofTypeAnnotation\"].concat(args));\n}\n\nfunction TypeAlias() {\n  for (var _len116 = arguments.length, args = new Array(_len116), _key116 = 0; _key116 < _len116; _key116++) {\n    args[_key116] = arguments[_key116];\n  }\n\n  return _builder.default.apply(void 0, [\"TypeAlias\"].concat(args));\n}\n\nfunction TypeAnnotation() {\n  for (var _len117 = arguments.length, args = new Array(_len117), _key117 = 0; _key117 < _len117; _key117++) {\n    args[_key117] = arguments[_key117];\n  }\n\n  return _builder.default.apply(void 0, [\"TypeAnnotation\"].concat(args));\n}\n\nfunction TypeCastExpression() {\n  for (var _len118 = arguments.length, args = new Array(_len118), _key118 = 0; _key118 < _len118; _key118++) {\n    args[_key118] = arguments[_key118];\n  }\n\n  return _builder.default.apply(void 0, [\"TypeCastExpression\"].concat(args));\n}\n\nfunction TypeParameter() {\n  for (var _len119 = arguments.length, args = new Array(_len119), _key119 = 0; _key119 < _len119; _key119++) {\n    args[_key119] = arguments[_key119];\n  }\n\n  return _builder.default.apply(void 0, [\"TypeParameter\"].concat(args));\n}\n\nfunction TypeParameterDeclaration() {\n  for (var _len120 = arguments.length, args = new Array(_len120), _key120 = 0; _key120 < _len120; _key120++) {\n    args[_key120] = arguments[_key120];\n  }\n\n  return _builder.default.apply(void 0, [\"TypeParameterDeclaration\"].concat(args));\n}\n\nfunction TypeParameterInstantiation() {\n  for (var _len121 = arguments.length, args = new Array(_len121), _key121 = 0; _key121 < _len121; _key121++) {\n    args[_key121] = arguments[_key121];\n  }\n\n  return _builder.default.apply(void 0, [\"TypeParameterInstantiation\"].concat(args));\n}\n\nfunction UnionTypeAnnotation() {\n  for (var _len122 = arguments.length, args = new Array(_len122), _key122 = 0; _key122 < _len122; _key122++) {\n    args[_key122] = arguments[_key122];\n  }\n\n  return _builder.default.apply(void 0, [\"UnionTypeAnnotation\"].concat(args));\n}\n\nfunction Variance() {\n  for (var _len123 = arguments.length, args = new Array(_len123), _key123 = 0; _key123 < _len123; _key123++) {\n    args[_key123] = arguments[_key123];\n  }\n\n  return _builder.default.apply(void 0, [\"Variance\"].concat(args));\n}\n\nfunction VoidTypeAnnotation() {\n  for (var _len124 = arguments.length, args = new Array(_len124), _key124 = 0; _key124 < _len124; _key124++) {\n    args[_key124] = arguments[_key124];\n  }\n\n  return _builder.default.apply(void 0, [\"VoidTypeAnnotation\"].concat(args));\n}\n\nfunction JSXAttribute() {\n  for (var _len125 = arguments.length, args = new Array(_len125), _key125 = 0; _key125 < _len125; _key125++) {\n    args[_key125] = arguments[_key125];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXAttribute\"].concat(args));\n}\n\nfunction JSXClosingElement() {\n  for (var _len126 = arguments.length, args = new Array(_len126), _key126 = 0; _key126 < _len126; _key126++) {\n    args[_key126] = arguments[_key126];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXClosingElement\"].concat(args));\n}\n\nfunction JSXElement() {\n  for (var _len127 = arguments.length, args = new Array(_len127), _key127 = 0; _key127 < _len127; _key127++) {\n    args[_key127] = arguments[_key127];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXElement\"].concat(args));\n}\n\nfunction JSXEmptyExpression() {\n  for (var _len128 = arguments.length, args = new Array(_len128), _key128 = 0; _key128 < _len128; _key128++) {\n    args[_key128] = arguments[_key128];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXEmptyExpression\"].concat(args));\n}\n\nfunction JSXExpressionContainer() {\n  for (var _len129 = arguments.length, args = new Array(_len129), _key129 = 0; _key129 < _len129; _key129++) {\n    args[_key129] = arguments[_key129];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXExpressionContainer\"].concat(args));\n}\n\nfunction JSXSpreadChild() {\n  for (var _len130 = arguments.length, args = new Array(_len130), _key130 = 0; _key130 < _len130; _key130++) {\n    args[_key130] = arguments[_key130];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXSpreadChild\"].concat(args));\n}\n\nfunction JSXIdentifier() {\n  for (var _len131 = arguments.length, args = new Array(_len131), _key131 = 0; _key131 < _len131; _key131++) {\n    args[_key131] = arguments[_key131];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXIdentifier\"].concat(args));\n}\n\nfunction JSXMemberExpression() {\n  for (var _len132 = arguments.length, args = new Array(_len132), _key132 = 0; _key132 < _len132; _key132++) {\n    args[_key132] = arguments[_key132];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXMemberExpression\"].concat(args));\n}\n\nfunction JSXNamespacedName() {\n  for (var _len133 = arguments.length, args = new Array(_len133), _key133 = 0; _key133 < _len133; _key133++) {\n    args[_key133] = arguments[_key133];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXNamespacedName\"].concat(args));\n}\n\nfunction JSXOpeningElement() {\n  for (var _len134 = arguments.length, args = new Array(_len134), _key134 = 0; _key134 < _len134; _key134++) {\n    args[_key134] = arguments[_key134];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXOpeningElement\"].concat(args));\n}\n\nfunction JSXSpreadAttribute() {\n  for (var _len135 = arguments.length, args = new Array(_len135), _key135 = 0; _key135 < _len135; _key135++) {\n    args[_key135] = arguments[_key135];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXSpreadAttribute\"].concat(args));\n}\n\nfunction JSXText() {\n  for (var _len136 = arguments.length, args = new Array(_len136), _key136 = 0; _key136 < _len136; _key136++) {\n    args[_key136] = arguments[_key136];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXText\"].concat(args));\n}\n\nfunction JSXFragment() {\n  for (var _len137 = arguments.length, args = new Array(_len137), _key137 = 0; _key137 < _len137; _key137++) {\n    args[_key137] = arguments[_key137];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXFragment\"].concat(args));\n}\n\nfunction JSXOpeningFragment() {\n  for (var _len138 = arguments.length, args = new Array(_len138), _key138 = 0; _key138 < _len138; _key138++) {\n    args[_key138] = arguments[_key138];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXOpeningFragment\"].concat(args));\n}\n\nfunction JSXClosingFragment() {\n  for (var _len139 = arguments.length, args = new Array(_len139), _key139 = 0; _key139 < _len139; _key139++) {\n    args[_key139] = arguments[_key139];\n  }\n\n  return _builder.default.apply(void 0, [\"JSXClosingFragment\"].concat(args));\n}\n\nfunction Noop() {\n  for (var _len140 = arguments.length, args = new Array(_len140), _key140 = 0; _key140 < _len140; _key140++) {\n    args[_key140] = arguments[_key140];\n  }\n\n  return _builder.default.apply(void 0, [\"Noop\"].concat(args));\n}\n\nfunction ParenthesizedExpression() {\n  for (var _len141 = arguments.length, args = new Array(_len141), _key141 = 0; _key141 < _len141; _key141++) {\n    args[_key141] = arguments[_key141];\n  }\n\n  return _builder.default.apply(void 0, [\"ParenthesizedExpression\"].concat(args));\n}\n\nfunction AwaitExpression() {\n  for (var _len142 = arguments.length, args = new Array(_len142), _key142 = 0; _key142 < _len142; _key142++) {\n    args[_key142] = arguments[_key142];\n  }\n\n  return _builder.default.apply(void 0, [\"AwaitExpression\"].concat(args));\n}\n\nfunction BindExpression() {\n  for (var _len143 = arguments.length, args = new Array(_len143), _key143 = 0; _key143 < _len143; _key143++) {\n    args[_key143] = arguments[_key143];\n  }\n\n  return _builder.default.apply(void 0, [\"BindExpression\"].concat(args));\n}\n\nfunction ClassProperty() {\n  for (var _len144 = arguments.length, args = new Array(_len144), _key144 = 0; _key144 < _len144; _key144++) {\n    args[_key144] = arguments[_key144];\n  }\n\n  return _builder.default.apply(void 0, [\"ClassProperty\"].concat(args));\n}\n\nfunction OptionalMemberExpression() {\n  for (var _len145 = arguments.length, args = new Array(_len145), _key145 = 0; _key145 < _len145; _key145++) {\n    args[_key145] = arguments[_key145];\n  }\n\n  return _builder.default.apply(void 0, [\"OptionalMemberExpression\"].concat(args));\n}\n\nfunction OptionalCallExpression() {\n  for (var _len146 = arguments.length, args = new Array(_len146), _key146 = 0; _key146 < _len146; _key146++) {\n    args[_key146] = arguments[_key146];\n  }\n\n  return _builder.default.apply(void 0, [\"OptionalCallExpression\"].concat(args));\n}\n\nfunction Import() {\n  for (var _len147 = arguments.length, args = new Array(_len147), _key147 = 0; _key147 < _len147; _key147++) {\n    args[_key147] = arguments[_key147];\n  }\n\n  return _builder.default.apply(void 0, [\"Import\"].concat(args));\n}\n\nfunction Decorator() {\n  for (var _len148 = arguments.length, args = new Array(_len148), _key148 = 0; _key148 < _len148; _key148++) {\n    args[_key148] = arguments[_key148];\n  }\n\n  return _builder.default.apply(void 0, [\"Decorator\"].concat(args));\n}\n\nfunction DoExpression() {\n  for (var _len149 = arguments.length, args = new Array(_len149), _key149 = 0; _key149 < _len149; _key149++) {\n    args[_key149] = arguments[_key149];\n  }\n\n  return _builder.default.apply(void 0, [\"DoExpression\"].concat(args));\n}\n\nfunction ExportDefaultSpecifier() {\n  for (var _len150 = arguments.length, args = new Array(_len150), _key150 = 0; _key150 < _len150; _key150++) {\n    args[_key150] = arguments[_key150];\n  }\n\n  return _builder.default.apply(void 0, [\"ExportDefaultSpecifier\"].concat(args));\n}\n\nfunction ExportNamespaceSpecifier() {\n  for (var _len151 = arguments.length, args = new Array(_len151), _key151 = 0; _key151 < _len151; _key151++) {\n    args[_key151] = arguments[_key151];\n  }\n\n  return _builder.default.apply(void 0, [\"ExportNamespaceSpecifier\"].concat(args));\n}\n\nfunction TSParameterProperty() {\n  for (var _len152 = arguments.length, args = new Array(_len152), _key152 = 0; _key152 < _len152; _key152++) {\n    args[_key152] = arguments[_key152];\n  }\n\n  return _builder.default.apply(void 0, [\"TSParameterProperty\"].concat(args));\n}\n\nfunction TSDeclareFunction() {\n  for (var _len153 = arguments.length, args = new Array(_len153), _key153 = 0; _key153 < _len153; _key153++) {\n    args[_key153] = arguments[_key153];\n  }\n\n  return _builder.default.apply(void 0, [\"TSDeclareFunction\"].concat(args));\n}\n\nfunction TSDeclareMethod() {\n  for (var _len154 = arguments.length, args = new Array(_len154), _key154 = 0; _key154 < _len154; _key154++) {\n    args[_key154] = arguments[_key154];\n  }\n\n  return _builder.default.apply(void 0, [\"TSDeclareMethod\"].concat(args));\n}\n\nfunction TSQualifiedName() {\n  for (var _len155 = arguments.length, args = new Array(_len155), _key155 = 0; _key155 < _len155; _key155++) {\n    args[_key155] = arguments[_key155];\n  }\n\n  return _builder.default.apply(void 0, [\"TSQualifiedName\"].concat(args));\n}\n\nfunction TSCallSignatureDeclaration() {\n  for (var _len156 = arguments.length, args = new Array(_len156), _key156 = 0; _key156 < _len156; _key156++) {\n    args[_key156] = arguments[_key156];\n  }\n\n  return _builder.default.apply(void 0, [\"TSCallSignatureDeclaration\"].concat(args));\n}\n\nfunction TSConstructSignatureDeclaration() {\n  for (var _len157 = arguments.length, args = new Array(_len157), _key157 = 0; _key157 < _len157; _key157++) {\n    args[_key157] = arguments[_key157];\n  }\n\n  return _builder.default.apply(void 0, [\"TSConstructSignatureDeclaration\"].concat(args));\n}\n\nfunction TSPropertySignature() {\n  for (var _len158 = arguments.length, args = new Array(_len158), _key158 = 0; _key158 < _len158; _key158++) {\n    args[_key158] = arguments[_key158];\n  }\n\n  return _builder.default.apply(void 0, [\"TSPropertySignature\"].concat(args));\n}\n\nfunction TSMethodSignature() {\n  for (var _len159 = arguments.length, args = new Array(_len159), _key159 = 0; _key159 < _len159; _key159++) {\n    args[_key159] = arguments[_key159];\n  }\n\n  return _builder.default.apply(void 0, [\"TSMethodSignature\"].concat(args));\n}\n\nfunction TSIndexSignature() {\n  for (var _len160 = arguments.length, args = new Array(_len160), _key160 = 0; _key160 < _len160; _key160++) {\n    args[_key160] = arguments[_key160];\n  }\n\n  return _builder.default.apply(void 0, [\"TSIndexSignature\"].concat(args));\n}\n\nfunction TSAnyKeyword() {\n  for (var _len161 = arguments.length, args = new Array(_len161), _key161 = 0; _key161 < _len161; _key161++) {\n    args[_key161] = arguments[_key161];\n  }\n\n  return _builder.default.apply(void 0, [\"TSAnyKeyword\"].concat(args));\n}\n\nfunction TSNumberKeyword() {\n  for (var _len162 = arguments.length, args = new Array(_len162), _key162 = 0; _key162 < _len162; _key162++) {\n    args[_key162] = arguments[_key162];\n  }\n\n  return _builder.default.apply(void 0, [\"TSNumberKeyword\"].concat(args));\n}\n\nfunction TSObjectKeyword() {\n  for (var _len163 = arguments.length, args = new Array(_len163), _key163 = 0; _key163 < _len163; _key163++) {\n    args[_key163] = arguments[_key163];\n  }\n\n  return _builder.default.apply(void 0, [\"TSObjectKeyword\"].concat(args));\n}\n\nfunction TSBooleanKeyword() {\n  for (var _len164 = arguments.length, args = new Array(_len164), _key164 = 0; _key164 < _len164; _key164++) {\n    args[_key164] = arguments[_key164];\n  }\n\n  return _builder.default.apply(void 0, [\"TSBooleanKeyword\"].concat(args));\n}\n\nfunction TSStringKeyword() {\n  for (var _len165 = arguments.length, args = new Array(_len165), _key165 = 0; _key165 < _len165; _key165++) {\n    args[_key165] = arguments[_key165];\n  }\n\n  return _builder.default.apply(void 0, [\"TSStringKeyword\"].concat(args));\n}\n\nfunction TSSymbolKeyword() {\n  for (var _len166 = arguments.length, args = new Array(_len166), _key166 = 0; _key166 < _len166; _key166++) {\n    args[_key166] = arguments[_key166];\n  }\n\n  return _builder.default.apply(void 0, [\"TSSymbolKeyword\"].concat(args));\n}\n\nfunction TSVoidKeyword() {\n  for (var _len167 = arguments.length, args = new Array(_len167), _key167 = 0; _key167 < _len167; _key167++) {\n    args[_key167] = arguments[_key167];\n  }\n\n  return _builder.default.apply(void 0, [\"TSVoidKeyword\"].concat(args));\n}\n\nfunction TSUndefinedKeyword() {\n  for (var _len168 = arguments.length, args = new Array(_len168), _key168 = 0; _key168 < _len168; _key168++) {\n    args[_key168] = arguments[_key168];\n  }\n\n  return _builder.default.apply(void 0, [\"TSUndefinedKeyword\"].concat(args));\n}\n\nfunction TSNullKeyword() {\n  for (var _len169 = arguments.length, args = new Array(_len169), _key169 = 0; _key169 < _len169; _key169++) {\n    args[_key169] = arguments[_key169];\n  }\n\n  return _builder.default.apply(void 0, [\"TSNullKeyword\"].concat(args));\n}\n\nfunction TSNeverKeyword() {\n  for (var _len170 = arguments.length, args = new Array(_len170), _key170 = 0; _key170 < _len170; _key170++) {\n    args[_key170] = arguments[_key170];\n  }\n\n  return _builder.default.apply(void 0, [\"TSNeverKeyword\"].concat(args));\n}\n\nfunction TSThisType() {\n  for (var _len171 = arguments.length, args = new Array(_len171), _key171 = 0; _key171 < _len171; _key171++) {\n    args[_key171] = arguments[_key171];\n  }\n\n  return _builder.default.apply(void 0, [\"TSThisType\"].concat(args));\n}\n\nfunction TSFunctionType() {\n  for (var _len172 = arguments.length, args = new Array(_len172), _key172 = 0; _key172 < _len172; _key172++) {\n    args[_key172] = arguments[_key172];\n  }\n\n  return _builder.default.apply(void 0, [\"TSFunctionType\"].concat(args));\n}\n\nfunction TSConstructorType() {\n  for (var _len173 = arguments.length, args = new Array(_len173), _key173 = 0; _key173 < _len173; _key173++) {\n    args[_key173] = arguments[_key173];\n  }\n\n  return _builder.default.apply(void 0, [\"TSConstructorType\"].concat(args));\n}\n\nfunction TSTypeReference() {\n  for (var _len174 = arguments.length, args = new Array(_len174), _key174 = 0; _key174 < _len174; _key174++) {\n    args[_key174] = arguments[_key174];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeReference\"].concat(args));\n}\n\nfunction TSTypePredicate() {\n  for (var _len175 = arguments.length, args = new Array(_len175), _key175 = 0; _key175 < _len175; _key175++) {\n    args[_key175] = arguments[_key175];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypePredicate\"].concat(args));\n}\n\nfunction TSTypeQuery() {\n  for (var _len176 = arguments.length, args = new Array(_len176), _key176 = 0; _key176 < _len176; _key176++) {\n    args[_key176] = arguments[_key176];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeQuery\"].concat(args));\n}\n\nfunction TSTypeLiteral() {\n  for (var _len177 = arguments.length, args = new Array(_len177), _key177 = 0; _key177 < _len177; _key177++) {\n    args[_key177] = arguments[_key177];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeLiteral\"].concat(args));\n}\n\nfunction TSArrayType() {\n  for (var _len178 = arguments.length, args = new Array(_len178), _key178 = 0; _key178 < _len178; _key178++) {\n    args[_key178] = arguments[_key178];\n  }\n\n  return _builder.default.apply(void 0, [\"TSArrayType\"].concat(args));\n}\n\nfunction TSTupleType() {\n  for (var _len179 = arguments.length, args = new Array(_len179), _key179 = 0; _key179 < _len179; _key179++) {\n    args[_key179] = arguments[_key179];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTupleType\"].concat(args));\n}\n\nfunction TSUnionType() {\n  for (var _len180 = arguments.length, args = new Array(_len180), _key180 = 0; _key180 < _len180; _key180++) {\n    args[_key180] = arguments[_key180];\n  }\n\n  return _builder.default.apply(void 0, [\"TSUnionType\"].concat(args));\n}\n\nfunction TSIntersectionType() {\n  for (var _len181 = arguments.length, args = new Array(_len181), _key181 = 0; _key181 < _len181; _key181++) {\n    args[_key181] = arguments[_key181];\n  }\n\n  return _builder.default.apply(void 0, [\"TSIntersectionType\"].concat(args));\n}\n\nfunction TSConditionalType() {\n  for (var _len182 = arguments.length, args = new Array(_len182), _key182 = 0; _key182 < _len182; _key182++) {\n    args[_key182] = arguments[_key182];\n  }\n\n  return _builder.default.apply(void 0, [\"TSConditionalType\"].concat(args));\n}\n\nfunction TSInferType() {\n  for (var _len183 = arguments.length, args = new Array(_len183), _key183 = 0; _key183 < _len183; _key183++) {\n    args[_key183] = arguments[_key183];\n  }\n\n  return _builder.default.apply(void 0, [\"TSInferType\"].concat(args));\n}\n\nfunction TSParenthesizedType() {\n  for (var _len184 = arguments.length, args = new Array(_len184), _key184 = 0; _key184 < _len184; _key184++) {\n    args[_key184] = arguments[_key184];\n  }\n\n  return _builder.default.apply(void 0, [\"TSParenthesizedType\"].concat(args));\n}\n\nfunction TSTypeOperator() {\n  for (var _len185 = arguments.length, args = new Array(_len185), _key185 = 0; _key185 < _len185; _key185++) {\n    args[_key185] = arguments[_key185];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeOperator\"].concat(args));\n}\n\nfunction TSIndexedAccessType() {\n  for (var _len186 = arguments.length, args = new Array(_len186), _key186 = 0; _key186 < _len186; _key186++) {\n    args[_key186] = arguments[_key186];\n  }\n\n  return _builder.default.apply(void 0, [\"TSIndexedAccessType\"].concat(args));\n}\n\nfunction TSMappedType() {\n  for (var _len187 = arguments.length, args = new Array(_len187), _key187 = 0; _key187 < _len187; _key187++) {\n    args[_key187] = arguments[_key187];\n  }\n\n  return _builder.default.apply(void 0, [\"TSMappedType\"].concat(args));\n}\n\nfunction TSLiteralType() {\n  for (var _len188 = arguments.length, args = new Array(_len188), _key188 = 0; _key188 < _len188; _key188++) {\n    args[_key188] = arguments[_key188];\n  }\n\n  return _builder.default.apply(void 0, [\"TSLiteralType\"].concat(args));\n}\n\nfunction TSExpressionWithTypeArguments() {\n  for (var _len189 = arguments.length, args = new Array(_len189), _key189 = 0; _key189 < _len189; _key189++) {\n    args[_key189] = arguments[_key189];\n  }\n\n  return _builder.default.apply(void 0, [\"TSExpressionWithTypeArguments\"].concat(args));\n}\n\nfunction TSInterfaceDeclaration() {\n  for (var _len190 = arguments.length, args = new Array(_len190), _key190 = 0; _key190 < _len190; _key190++) {\n    args[_key190] = arguments[_key190];\n  }\n\n  return _builder.default.apply(void 0, [\"TSInterfaceDeclaration\"].concat(args));\n}\n\nfunction TSInterfaceBody() {\n  for (var _len191 = arguments.length, args = new Array(_len191), _key191 = 0; _key191 < _len191; _key191++) {\n    args[_key191] = arguments[_key191];\n  }\n\n  return _builder.default.apply(void 0, [\"TSInterfaceBody\"].concat(args));\n}\n\nfunction TSTypeAliasDeclaration() {\n  for (var _len192 = arguments.length, args = new Array(_len192), _key192 = 0; _key192 < _len192; _key192++) {\n    args[_key192] = arguments[_key192];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeAliasDeclaration\"].concat(args));\n}\n\nfunction TSAsExpression() {\n  for (var _len193 = arguments.length, args = new Array(_len193), _key193 = 0; _key193 < _len193; _key193++) {\n    args[_key193] = arguments[_key193];\n  }\n\n  return _builder.default.apply(void 0, [\"TSAsExpression\"].concat(args));\n}\n\nfunction TSTypeAssertion() {\n  for (var _len194 = arguments.length, args = new Array(_len194), _key194 = 0; _key194 < _len194; _key194++) {\n    args[_key194] = arguments[_key194];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeAssertion\"].concat(args));\n}\n\nfunction TSEnumDeclaration() {\n  for (var _len195 = arguments.length, args = new Array(_len195), _key195 = 0; _key195 < _len195; _key195++) {\n    args[_key195] = arguments[_key195];\n  }\n\n  return _builder.default.apply(void 0, [\"TSEnumDeclaration\"].concat(args));\n}\n\nfunction TSEnumMember() {\n  for (var _len196 = arguments.length, args = new Array(_len196), _key196 = 0; _key196 < _len196; _key196++) {\n    args[_key196] = arguments[_key196];\n  }\n\n  return _builder.default.apply(void 0, [\"TSEnumMember\"].concat(args));\n}\n\nfunction TSModuleDeclaration() {\n  for (var _len197 = arguments.length, args = new Array(_len197), _key197 = 0; _key197 < _len197; _key197++) {\n    args[_key197] = arguments[_key197];\n  }\n\n  return _builder.default.apply(void 0, [\"TSModuleDeclaration\"].concat(args));\n}\n\nfunction TSModuleBlock() {\n  for (var _len198 = arguments.length, args = new Array(_len198), _key198 = 0; _key198 < _len198; _key198++) {\n    args[_key198] = arguments[_key198];\n  }\n\n  return _builder.default.apply(void 0, [\"TSModuleBlock\"].concat(args));\n}\n\nfunction TSImportEqualsDeclaration() {\n  for (var _len199 = arguments.length, args = new Array(_len199), _key199 = 0; _key199 < _len199; _key199++) {\n    args[_key199] = arguments[_key199];\n  }\n\n  return _builder.default.apply(void 0, [\"TSImportEqualsDeclaration\"].concat(args));\n}\n\nfunction TSExternalModuleReference() {\n  for (var _len200 = arguments.length, args = new Array(_len200), _key200 = 0; _key200 < _len200; _key200++) {\n    args[_key200] = arguments[_key200];\n  }\n\n  return _builder.default.apply(void 0, [\"TSExternalModuleReference\"].concat(args));\n}\n\nfunction TSNonNullExpression() {\n  for (var _len201 = arguments.length, args = new Array(_len201), _key201 = 0; _key201 < _len201; _key201++) {\n    args[_key201] = arguments[_key201];\n  }\n\n  return _builder.default.apply(void 0, [\"TSNonNullExpression\"].concat(args));\n}\n\nfunction TSExportAssignment() {\n  for (var _len202 = arguments.length, args = new Array(_len202), _key202 = 0; _key202 < _len202; _key202++) {\n    args[_key202] = arguments[_key202];\n  }\n\n  return _builder.default.apply(void 0, [\"TSExportAssignment\"].concat(args));\n}\n\nfunction TSNamespaceExportDeclaration() {\n  for (var _len203 = arguments.length, args = new Array(_len203), _key203 = 0; _key203 < _len203; _key203++) {\n    args[_key203] = arguments[_key203];\n  }\n\n  return _builder.default.apply(void 0, [\"TSNamespaceExportDeclaration\"].concat(args));\n}\n\nfunction TSTypeAnnotation() {\n  for (var _len204 = arguments.length, args = new Array(_len204), _key204 = 0; _key204 < _len204; _key204++) {\n    args[_key204] = arguments[_key204];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeAnnotation\"].concat(args));\n}\n\nfunction TSTypeParameterInstantiation() {\n  for (var _len205 = arguments.length, args = new Array(_len205), _key205 = 0; _key205 < _len205; _key205++) {\n    args[_key205] = arguments[_key205];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeParameterInstantiation\"].concat(args));\n}\n\nfunction TSTypeParameterDeclaration() {\n  for (var _len206 = arguments.length, args = new Array(_len206), _key206 = 0; _key206 < _len206; _key206++) {\n    args[_key206] = arguments[_key206];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeParameterDeclaration\"].concat(args));\n}\n\nfunction TSTypeParameter() {\n  for (var _len207 = arguments.length, args = new Array(_len207), _key207 = 0; _key207 < _len207; _key207++) {\n    args[_key207] = arguments[_key207];\n  }\n\n  return _builder.default.apply(void 0, [\"TSTypeParameter\"].concat(args));\n}\n\nfunction NumberLiteral() {\n  console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n\n  for (var _len208 = arguments.length, args = new Array(_len208), _key208 = 0; _key208 < _len208; _key208++) {\n    args[_key208] = arguments[_key208];\n  }\n\n  return NumberLiteral.apply(void 0, [\"NumberLiteral\"].concat(args));\n}\n\nfunction RegexLiteral() {\n  console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n\n  for (var _len209 = arguments.length, args = new Array(_len209), _key209 = 0; _key209 < _len209; _key209++) {\n    args[_key209] = arguments[_key209];\n  }\n\n  return RegexLiteral.apply(void 0, [\"RegexLiteral\"].concat(args));\n}\n\nfunction RestProperty() {\n  console.trace(\"The node type RestProperty has been renamed to RestElement\");\n\n  for (var _len210 = arguments.length, args = new Array(_len210), _key210 = 0; _key210 < _len210; _key210++) {\n    args[_key210] = arguments[_key210];\n  }\n\n  return RestProperty.apply(void 0, [\"RestProperty\"].concat(args));\n}\n\nfunction SpreadProperty() {\n  console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n\n  for (var _len211 = arguments.length, args = new Array(_len211), _key211 = 0; _key211 < _len211; _key211++) {\n    args[_key211] = arguments[_key211];\n  }\n\n  return SpreadProperty.apply(void 0, [\"SpreadProperty\"].concat(args));\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = builder;\n\nfunction _clone() {\n  var data = _interopRequireDefault(require(\"lodash/clone\"));\n\n  _clone = function _clone() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _definitions = require(\"../definitions\");\n\nvar _validate = _interopRequireDefault(require(\"../validators/validate\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction builder(type) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var keys = _definitions.BUILDER_KEYS[type];\n  var countArgs = args.length;\n\n  if (countArgs > keys.length) {\n    throw new Error(type + \": Too many arguments passed. Received \" + countArgs + \" but can receive no more than \" + keys.length);\n  }\n\n  var node = {\n    type: type\n  };\n  var i = 0;\n  keys.forEach(function (key) {\n    var field = _definitions.NODE_FIELDS[type][key];\n    var arg;\n    if (i < countArgs) arg = args[i];\n    if (arg === undefined) arg = (0, _clone().default)(field.default);\n    node[key] = arg;\n    i++;\n  });\n\n  for (var key in node) {\n    (0, _validate.default)(node, key, node[key]);\n  }\n\n  return node;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = validate;\n\nvar _definitions = require(\"../definitions\");\n\nfunction validate(node, key, val) {\n  if (!node) return;\n  var fields = _definitions.NODE_FIELDS[node.type];\n  if (!fields) return;\n  var field = fields[key];\n  if (!field || !field.validate) return;\n  if (field.optional && val == null) return;\n  field.validate(node, key, val);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assertNode;\n\nvar _isNode = _interopRequireDefault(require(\"../validators/isNode\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction assertNode(node) {\n  if (!(0, _isNode.default)(node)) {\n    var type = node && node.type || JSON.stringify(node);\n    throw new TypeError(\"Not a valid node of type \\\"\" + type + \"\\\"\");\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isNode;\n\nvar _definitions = require(\"../definitions\");\n\nfunction isNode(node) {\n  return !!(node && _definitions.VISITOR_KEYS[node.type]);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertArrayExpression = assertArrayExpression;\nexports.assertAssignmentExpression = assertAssignmentExpression;\nexports.assertBinaryExpression = assertBinaryExpression;\nexports.assertDirective = assertDirective;\nexports.assertDirectiveLiteral = assertDirectiveLiteral;\nexports.assertBlockStatement = assertBlockStatement;\nexports.assertBreakStatement = assertBreakStatement;\nexports.assertCallExpression = assertCallExpression;\nexports.assertCatchClause = assertCatchClause;\nexports.assertConditionalExpression = assertConditionalExpression;\nexports.assertContinueStatement = assertContinueStatement;\nexports.assertDebuggerStatement = assertDebuggerStatement;\nexports.assertDoWhileStatement = assertDoWhileStatement;\nexports.assertEmptyStatement = assertEmptyStatement;\nexports.assertExpressionStatement = assertExpressionStatement;\nexports.assertFile = assertFile;\nexports.assertForInStatement = assertForInStatement;\nexports.assertForStatement = assertForStatement;\nexports.assertFunctionDeclaration = assertFunctionDeclaration;\nexports.assertFunctionExpression = assertFunctionExpression;\nexports.assertIdentifier = assertIdentifier;\nexports.assertIfStatement = assertIfStatement;\nexports.assertLabeledStatement = assertLabeledStatement;\nexports.assertStringLiteral = assertStringLiteral;\nexports.assertNumericLiteral = assertNumericLiteral;\nexports.assertNullLiteral = assertNullLiteral;\nexports.assertBooleanLiteral = assertBooleanLiteral;\nexports.assertRegExpLiteral = assertRegExpLiteral;\nexports.assertLogicalExpression = assertLogicalExpression;\nexports.assertMemberExpression = assertMemberExpression;\nexports.assertNewExpression = assertNewExpression;\nexports.assertProgram = assertProgram;\nexports.assertObjectExpression = assertObjectExpression;\nexports.assertObjectMethod = assertObjectMethod;\nexports.assertObjectProperty = assertObjectProperty;\nexports.assertRestElement = assertRestElement;\nexports.assertReturnStatement = assertReturnStatement;\nexports.assertSequenceExpression = assertSequenceExpression;\nexports.assertSwitchCase = assertSwitchCase;\nexports.assertSwitchStatement = assertSwitchStatement;\nexports.assertThisExpression = assertThisExpression;\nexports.assertThrowStatement = assertThrowStatement;\nexports.assertTryStatement = assertTryStatement;\nexports.assertUnaryExpression = assertUnaryExpression;\nexports.assertUpdateExpression = assertUpdateExpression;\nexports.assertVariableDeclaration = assertVariableDeclaration;\nexports.assertVariableDeclarator = assertVariableDeclarator;\nexports.assertWhileStatement = assertWhileStatement;\nexports.assertWithStatement = assertWithStatement;\nexports.assertAssignmentPattern = assertAssignmentPattern;\nexports.assertArrayPattern = assertArrayPattern;\nexports.assertArrowFunctionExpression = assertArrowFunctionExpression;\nexports.assertClassBody = assertClassBody;\nexports.assertClassDeclaration = assertClassDeclaration;\nexports.assertClassExpression = assertClassExpression;\nexports.assertExportAllDeclaration = assertExportAllDeclaration;\nexports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;\nexports.assertExportNamedDeclaration = assertExportNamedDeclaration;\nexports.assertExportSpecifier = assertExportSpecifier;\nexports.assertForOfStatement = assertForOfStatement;\nexports.assertImportDeclaration = assertImportDeclaration;\nexports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;\nexports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;\nexports.assertImportSpecifier = assertImportSpecifier;\nexports.assertMetaProperty = assertMetaProperty;\nexports.assertClassMethod = assertClassMethod;\nexports.assertObjectPattern = assertObjectPattern;\nexports.assertSpreadElement = assertSpreadElement;\nexports.assertSuper = assertSuper;\nexports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;\nexports.assertTemplateElement = assertTemplateElement;\nexports.assertTemplateLiteral = assertTemplateLiteral;\nexports.assertYieldExpression = assertYieldExpression;\nexports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;\nexports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;\nexports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;\nexports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;\nexports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;\nexports.assertClassImplements = assertClassImplements;\nexports.assertDeclareClass = assertDeclareClass;\nexports.assertDeclareFunction = assertDeclareFunction;\nexports.assertDeclareInterface = assertDeclareInterface;\nexports.assertDeclareModule = assertDeclareModule;\nexports.assertDeclareModuleExports = assertDeclareModuleExports;\nexports.assertDeclareTypeAlias = assertDeclareTypeAlias;\nexports.assertDeclareOpaqueType = assertDeclareOpaqueType;\nexports.assertDeclareVariable = assertDeclareVariable;\nexports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;\nexports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;\nexports.assertDeclaredPredicate = assertDeclaredPredicate;\nexports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;\nexports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;\nexports.assertFunctionTypeParam = assertFunctionTypeParam;\nexports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;\nexports.assertInferredPredicate = assertInferredPredicate;\nexports.assertInterfaceExtends = assertInterfaceExtends;\nexports.assertInterfaceDeclaration = assertInterfaceDeclaration;\nexports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;\nexports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;\nexports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;\nexports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;\nexports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;\nexports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;\nexports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;\nexports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;\nexports.assertObjectTypeIndexer = assertObjectTypeIndexer;\nexports.assertObjectTypeProperty = assertObjectTypeProperty;\nexports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;\nexports.assertOpaqueType = assertOpaqueType;\nexports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;\nexports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;\nexports.assertStringTypeAnnotation = assertStringTypeAnnotation;\nexports.assertThisTypeAnnotation = assertThisTypeAnnotation;\nexports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;\nexports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;\nexports.assertTypeAlias = assertTypeAlias;\nexports.assertTypeAnnotation = assertTypeAnnotation;\nexports.assertTypeCastExpression = assertTypeCastExpression;\nexports.assertTypeParameter = assertTypeParameter;\nexports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;\nexports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;\nexports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;\nexports.assertVariance = assertVariance;\nexports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;\nexports.assertJSXAttribute = assertJSXAttribute;\nexports.assertJSXClosingElement = assertJSXClosingElement;\nexports.assertJSXElement = assertJSXElement;\nexports.assertJSXEmptyExpression = assertJSXEmptyExpression;\nexports.assertJSXExpressionContainer = assertJSXExpressionContainer;\nexports.assertJSXSpreadChild = assertJSXSpreadChild;\nexports.assertJSXIdentifier = assertJSXIdentifier;\nexports.assertJSXMemberExpression = assertJSXMemberExpression;\nexports.assertJSXNamespacedName = assertJSXNamespacedName;\nexports.assertJSXOpeningElement = assertJSXOpeningElement;\nexports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;\nexports.assertJSXText = assertJSXText;\nexports.assertJSXFragment = assertJSXFragment;\nexports.assertJSXOpeningFragment = assertJSXOpeningFragment;\nexports.assertJSXClosingFragment = assertJSXClosingFragment;\nexports.assertNoop = assertNoop;\nexports.assertParenthesizedExpression = assertParenthesizedExpression;\nexports.assertAwaitExpression = assertAwaitExpression;\nexports.assertBindExpression = assertBindExpression;\nexports.assertClassProperty = assertClassProperty;\nexports.assertOptionalMemberExpression = assertOptionalMemberExpression;\nexports.assertOptionalCallExpression = assertOptionalCallExpression;\nexports.assertImport = assertImport;\nexports.assertDecorator = assertDecorator;\nexports.assertDoExpression = assertDoExpression;\nexports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;\nexports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;\nexports.assertTSParameterProperty = assertTSParameterProperty;\nexports.assertTSDeclareFunction = assertTSDeclareFunction;\nexports.assertTSDeclareMethod = assertTSDeclareMethod;\nexports.assertTSQualifiedName = assertTSQualifiedName;\nexports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;\nexports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;\nexports.assertTSPropertySignature = assertTSPropertySignature;\nexports.assertTSMethodSignature = assertTSMethodSignature;\nexports.assertTSIndexSignature = assertTSIndexSignature;\nexports.assertTSAnyKeyword = assertTSAnyKeyword;\nexports.assertTSNumberKeyword = assertTSNumberKeyword;\nexports.assertTSObjectKeyword = assertTSObjectKeyword;\nexports.assertTSBooleanKeyword = assertTSBooleanKeyword;\nexports.assertTSStringKeyword = assertTSStringKeyword;\nexports.assertTSSymbolKeyword = assertTSSymbolKeyword;\nexports.assertTSVoidKeyword = assertTSVoidKeyword;\nexports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;\nexports.assertTSNullKeyword = assertTSNullKeyword;\nexports.assertTSNeverKeyword = assertTSNeverKeyword;\nexports.assertTSThisType = assertTSThisType;\nexports.assertTSFunctionType = assertTSFunctionType;\nexports.assertTSConstructorType = assertTSConstructorType;\nexports.assertTSTypeReference = assertTSTypeReference;\nexports.assertTSTypePredicate = assertTSTypePredicate;\nexports.assertTSTypeQuery = assertTSTypeQuery;\nexports.assertTSTypeLiteral = assertTSTypeLiteral;\nexports.assertTSArrayType = assertTSArrayType;\nexports.assertTSTupleType = assertTSTupleType;\nexports.assertTSUnionType = assertTSUnionType;\nexports.assertTSIntersectionType = assertTSIntersectionType;\nexports.assertTSConditionalType = assertTSConditionalType;\nexports.assertTSInferType = assertTSInferType;\nexports.assertTSParenthesizedType = assertTSParenthesizedType;\nexports.assertTSTypeOperator = assertTSTypeOperator;\nexports.assertTSIndexedAccessType = assertTSIndexedAccessType;\nexports.assertTSMappedType = assertTSMappedType;\nexports.assertTSLiteralType = assertTSLiteralType;\nexports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;\nexports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;\nexports.assertTSInterfaceBody = assertTSInterfaceBody;\nexports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;\nexports.assertTSAsExpression = assertTSAsExpression;\nexports.assertTSTypeAssertion = assertTSTypeAssertion;\nexports.assertTSEnumDeclaration = assertTSEnumDeclaration;\nexports.assertTSEnumMember = assertTSEnumMember;\nexports.assertTSModuleDeclaration = assertTSModuleDeclaration;\nexports.assertTSModuleBlock = assertTSModuleBlock;\nexports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;\nexports.assertTSExternalModuleReference = assertTSExternalModuleReference;\nexports.assertTSNonNullExpression = assertTSNonNullExpression;\nexports.assertTSExportAssignment = assertTSExportAssignment;\nexports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;\nexports.assertTSTypeAnnotation = assertTSTypeAnnotation;\nexports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;\nexports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;\nexports.assertTSTypeParameter = assertTSTypeParameter;\nexports.assertExpression = assertExpression;\nexports.assertBinary = assertBinary;\nexports.assertScopable = assertScopable;\nexports.assertBlockParent = assertBlockParent;\nexports.assertBlock = assertBlock;\nexports.assertStatement = assertStatement;\nexports.assertTerminatorless = assertTerminatorless;\nexports.assertCompletionStatement = assertCompletionStatement;\nexports.assertConditional = assertConditional;\nexports.assertLoop = assertLoop;\nexports.assertWhile = assertWhile;\nexports.assertExpressionWrapper = assertExpressionWrapper;\nexports.assertFor = assertFor;\nexports.assertForXStatement = assertForXStatement;\nexports.assertFunction = assertFunction;\nexports.assertFunctionParent = assertFunctionParent;\nexports.assertPureish = assertPureish;\nexports.assertDeclaration = assertDeclaration;\nexports.assertPatternLike = assertPatternLike;\nexports.assertLVal = assertLVal;\nexports.assertTSEntityName = assertTSEntityName;\nexports.assertLiteral = assertLiteral;\nexports.assertImmutable = assertImmutable;\nexports.assertUserWhitespacable = assertUserWhitespacable;\nexports.assertMethod = assertMethod;\nexports.assertObjectMember = assertObjectMember;\nexports.assertProperty = assertProperty;\nexports.assertUnaryLike = assertUnaryLike;\nexports.assertPattern = assertPattern;\nexports.assertClass = assertClass;\nexports.assertModuleDeclaration = assertModuleDeclaration;\nexports.assertExportDeclaration = assertExportDeclaration;\nexports.assertModuleSpecifier = assertModuleSpecifier;\nexports.assertFlow = assertFlow;\nexports.assertFlowType = assertFlowType;\nexports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;\nexports.assertFlowDeclaration = assertFlowDeclaration;\nexports.assertFlowPredicate = assertFlowPredicate;\nexports.assertJSX = assertJSX;\nexports.assertTSTypeElement = assertTSTypeElement;\nexports.assertTSType = assertTSType;\nexports.assertNumberLiteral = assertNumberLiteral;\nexports.assertRegexLiteral = assertRegexLiteral;\nexports.assertRestProperty = assertRestProperty;\nexports.assertSpreadProperty = assertSpreadProperty;\n\nvar _is = _interopRequireDefault(require(\"../../validators/is\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction assert(type, node, opts) {\n  if (!(0, _is.default)(type, node, opts)) {\n    throw new Error(\"Expected type \\\"\" + type + \"\\\" with option \" + JSON.stringify(opts) + \", but instead got \\\"\" + node.type + \"\\\".\");\n  }\n}\n\nfunction assertArrayExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ArrayExpression\", node, opts);\n}\n\nfunction assertAssignmentExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"AssignmentExpression\", node, opts);\n}\n\nfunction assertBinaryExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"BinaryExpression\", node, opts);\n}\n\nfunction assertDirective(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Directive\", node, opts);\n}\n\nfunction assertDirectiveLiteral(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DirectiveLiteral\", node, opts);\n}\n\nfunction assertBlockStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"BlockStatement\", node, opts);\n}\n\nfunction assertBreakStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"BreakStatement\", node, opts);\n}\n\nfunction assertCallExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"CallExpression\", node, opts);\n}\n\nfunction assertCatchClause(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"CatchClause\", node, opts);\n}\n\nfunction assertConditionalExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ConditionalExpression\", node, opts);\n}\n\nfunction assertContinueStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ContinueStatement\", node, opts);\n}\n\nfunction assertDebuggerStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DebuggerStatement\", node, opts);\n}\n\nfunction assertDoWhileStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DoWhileStatement\", node, opts);\n}\n\nfunction assertEmptyStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"EmptyStatement\", node, opts);\n}\n\nfunction assertExpressionStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExpressionStatement\", node, opts);\n}\n\nfunction assertFile(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"File\", node, opts);\n}\n\nfunction assertForInStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ForInStatement\", node, opts);\n}\n\nfunction assertForStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ForStatement\", node, opts);\n}\n\nfunction assertFunctionDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"FunctionDeclaration\", node, opts);\n}\n\nfunction assertFunctionExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"FunctionExpression\", node, opts);\n}\n\nfunction assertIdentifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Identifier\", node, opts);\n}\n\nfunction assertIfStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"IfStatement\", node, opts);\n}\n\nfunction assertLabeledStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"LabeledStatement\", node, opts);\n}\n\nfunction assertStringLiteral(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"StringLiteral\", node, opts);\n}\n\nfunction assertNumericLiteral(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"NumericLiteral\", node, opts);\n}\n\nfunction assertNullLiteral(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"NullLiteral\", node, opts);\n}\n\nfunction assertBooleanLiteral(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"BooleanLiteral\", node, opts);\n}\n\nfunction assertRegExpLiteral(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"RegExpLiteral\", node, opts);\n}\n\nfunction assertLogicalExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"LogicalExpression\", node, opts);\n}\n\nfunction assertMemberExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"MemberExpression\", node, opts);\n}\n\nfunction assertNewExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"NewExpression\", node, opts);\n}\n\nfunction assertProgram(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Program\", node, opts);\n}\n\nfunction assertObjectExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectExpression\", node, opts);\n}\n\nfunction assertObjectMethod(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectMethod\", node, opts);\n}\n\nfunction assertObjectProperty(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectProperty\", node, opts);\n}\n\nfunction assertRestElement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"RestElement\", node, opts);\n}\n\nfunction assertReturnStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ReturnStatement\", node, opts);\n}\n\nfunction assertSequenceExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"SequenceExpression\", node, opts);\n}\n\nfunction assertSwitchCase(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"SwitchCase\", node, opts);\n}\n\nfunction assertSwitchStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"SwitchStatement\", node, opts);\n}\n\nfunction assertThisExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ThisExpression\", node, opts);\n}\n\nfunction assertThrowStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ThrowStatement\", node, opts);\n}\n\nfunction assertTryStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TryStatement\", node, opts);\n}\n\nfunction assertUnaryExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"UnaryExpression\", node, opts);\n}\n\nfunction assertUpdateExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"UpdateExpression\", node, opts);\n}\n\nfunction assertVariableDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"VariableDeclaration\", node, opts);\n}\n\nfunction assertVariableDeclarator(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"VariableDeclarator\", node, opts);\n}\n\nfunction assertWhileStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"WhileStatement\", node, opts);\n}\n\nfunction assertWithStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"WithStatement\", node, opts);\n}\n\nfunction assertAssignmentPattern(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"AssignmentPattern\", node, opts);\n}\n\nfunction assertArrayPattern(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ArrayPattern\", node, opts);\n}\n\nfunction assertArrowFunctionExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ArrowFunctionExpression\", node, opts);\n}\n\nfunction assertClassBody(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ClassBody\", node, opts);\n}\n\nfunction assertClassDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ClassDeclaration\", node, opts);\n}\n\nfunction assertClassExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ClassExpression\", node, opts);\n}\n\nfunction assertExportAllDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExportAllDeclaration\", node, opts);\n}\n\nfunction assertExportDefaultDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExportDefaultDeclaration\", node, opts);\n}\n\nfunction assertExportNamedDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExportNamedDeclaration\", node, opts);\n}\n\nfunction assertExportSpecifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExportSpecifier\", node, opts);\n}\n\nfunction assertForOfStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ForOfStatement\", node, opts);\n}\n\nfunction assertImportDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ImportDeclaration\", node, opts);\n}\n\nfunction assertImportDefaultSpecifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ImportDefaultSpecifier\", node, opts);\n}\n\nfunction assertImportNamespaceSpecifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ImportNamespaceSpecifier\", node, opts);\n}\n\nfunction assertImportSpecifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ImportSpecifier\", node, opts);\n}\n\nfunction assertMetaProperty(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"MetaProperty\", node, opts);\n}\n\nfunction assertClassMethod(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ClassMethod\", node, opts);\n}\n\nfunction assertObjectPattern(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectPattern\", node, opts);\n}\n\nfunction assertSpreadElement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"SpreadElement\", node, opts);\n}\n\nfunction assertSuper(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Super\", node, opts);\n}\n\nfunction assertTaggedTemplateExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TaggedTemplateExpression\", node, opts);\n}\n\nfunction assertTemplateElement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TemplateElement\", node, opts);\n}\n\nfunction assertTemplateLiteral(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TemplateLiteral\", node, opts);\n}\n\nfunction assertYieldExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"YieldExpression\", node, opts);\n}\n\nfunction assertAnyTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"AnyTypeAnnotation\", node, opts);\n}\n\nfunction assertArrayTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ArrayTypeAnnotation\", node, opts);\n}\n\nfunction assertBooleanTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"BooleanTypeAnnotation\", node, opts);\n}\n\nfunction assertBooleanLiteralTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"BooleanLiteralTypeAnnotation\", node, opts);\n}\n\nfunction assertNullLiteralTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"NullLiteralTypeAnnotation\", node, opts);\n}\n\nfunction assertClassImplements(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ClassImplements\", node, opts);\n}\n\nfunction assertDeclareClass(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareClass\", node, opts);\n}\n\nfunction assertDeclareFunction(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareFunction\", node, opts);\n}\n\nfunction assertDeclareInterface(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareInterface\", node, opts);\n}\n\nfunction assertDeclareModule(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareModule\", node, opts);\n}\n\nfunction assertDeclareModuleExports(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareModuleExports\", node, opts);\n}\n\nfunction assertDeclareTypeAlias(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareTypeAlias\", node, opts);\n}\n\nfunction assertDeclareOpaqueType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareOpaqueType\", node, opts);\n}\n\nfunction assertDeclareVariable(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareVariable\", node, opts);\n}\n\nfunction assertDeclareExportDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareExportDeclaration\", node, opts);\n}\n\nfunction assertDeclareExportAllDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclareExportAllDeclaration\", node, opts);\n}\n\nfunction assertDeclaredPredicate(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DeclaredPredicate\", node, opts);\n}\n\nfunction assertExistsTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExistsTypeAnnotation\", node, opts);\n}\n\nfunction assertFunctionTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"FunctionTypeAnnotation\", node, opts);\n}\n\nfunction assertFunctionTypeParam(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"FunctionTypeParam\", node, opts);\n}\n\nfunction assertGenericTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"GenericTypeAnnotation\", node, opts);\n}\n\nfunction assertInferredPredicate(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"InferredPredicate\", node, opts);\n}\n\nfunction assertInterfaceExtends(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"InterfaceExtends\", node, opts);\n}\n\nfunction assertInterfaceDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"InterfaceDeclaration\", node, opts);\n}\n\nfunction assertIntersectionTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"IntersectionTypeAnnotation\", node, opts);\n}\n\nfunction assertMixedTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"MixedTypeAnnotation\", node, opts);\n}\n\nfunction assertEmptyTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"EmptyTypeAnnotation\", node, opts);\n}\n\nfunction assertNullableTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"NullableTypeAnnotation\", node, opts);\n}\n\nfunction assertNumberLiteralTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"NumberLiteralTypeAnnotation\", node, opts);\n}\n\nfunction assertNumberTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"NumberTypeAnnotation\", node, opts);\n}\n\nfunction assertObjectTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectTypeAnnotation\", node, opts);\n}\n\nfunction assertObjectTypeCallProperty(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectTypeCallProperty\", node, opts);\n}\n\nfunction assertObjectTypeIndexer(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectTypeIndexer\", node, opts);\n}\n\nfunction assertObjectTypeProperty(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectTypeProperty\", node, opts);\n}\n\nfunction assertObjectTypeSpreadProperty(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectTypeSpreadProperty\", node, opts);\n}\n\nfunction assertOpaqueType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"OpaqueType\", node, opts);\n}\n\nfunction assertQualifiedTypeIdentifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"QualifiedTypeIdentifier\", node, opts);\n}\n\nfunction assertStringLiteralTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"StringLiteralTypeAnnotation\", node, opts);\n}\n\nfunction assertStringTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"StringTypeAnnotation\", node, opts);\n}\n\nfunction assertThisTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ThisTypeAnnotation\", node, opts);\n}\n\nfunction assertTupleTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TupleTypeAnnotation\", node, opts);\n}\n\nfunction assertTypeofTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TypeofTypeAnnotation\", node, opts);\n}\n\nfunction assertTypeAlias(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TypeAlias\", node, opts);\n}\n\nfunction assertTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TypeAnnotation\", node, opts);\n}\n\nfunction assertTypeCastExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TypeCastExpression\", node, opts);\n}\n\nfunction assertTypeParameter(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TypeParameter\", node, opts);\n}\n\nfunction assertTypeParameterDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TypeParameterDeclaration\", node, opts);\n}\n\nfunction assertTypeParameterInstantiation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TypeParameterInstantiation\", node, opts);\n}\n\nfunction assertUnionTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"UnionTypeAnnotation\", node, opts);\n}\n\nfunction assertVariance(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Variance\", node, opts);\n}\n\nfunction assertVoidTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"VoidTypeAnnotation\", node, opts);\n}\n\nfunction assertJSXAttribute(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXAttribute\", node, opts);\n}\n\nfunction assertJSXClosingElement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXClosingElement\", node, opts);\n}\n\nfunction assertJSXElement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXElement\", node, opts);\n}\n\nfunction assertJSXEmptyExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXEmptyExpression\", node, opts);\n}\n\nfunction assertJSXExpressionContainer(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXExpressionContainer\", node, opts);\n}\n\nfunction assertJSXSpreadChild(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXSpreadChild\", node, opts);\n}\n\nfunction assertJSXIdentifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXIdentifier\", node, opts);\n}\n\nfunction assertJSXMemberExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXMemberExpression\", node, opts);\n}\n\nfunction assertJSXNamespacedName(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXNamespacedName\", node, opts);\n}\n\nfunction assertJSXOpeningElement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXOpeningElement\", node, opts);\n}\n\nfunction assertJSXSpreadAttribute(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXSpreadAttribute\", node, opts);\n}\n\nfunction assertJSXText(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXText\", node, opts);\n}\n\nfunction assertJSXFragment(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXFragment\", node, opts);\n}\n\nfunction assertJSXOpeningFragment(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXOpeningFragment\", node, opts);\n}\n\nfunction assertJSXClosingFragment(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSXClosingFragment\", node, opts);\n}\n\nfunction assertNoop(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Noop\", node, opts);\n}\n\nfunction assertParenthesizedExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ParenthesizedExpression\", node, opts);\n}\n\nfunction assertAwaitExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"AwaitExpression\", node, opts);\n}\n\nfunction assertBindExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"BindExpression\", node, opts);\n}\n\nfunction assertClassProperty(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ClassProperty\", node, opts);\n}\n\nfunction assertOptionalMemberExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"OptionalMemberExpression\", node, opts);\n}\n\nfunction assertOptionalCallExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"OptionalCallExpression\", node, opts);\n}\n\nfunction assertImport(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Import\", node, opts);\n}\n\nfunction assertDecorator(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Decorator\", node, opts);\n}\n\nfunction assertDoExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"DoExpression\", node, opts);\n}\n\nfunction assertExportDefaultSpecifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExportDefaultSpecifier\", node, opts);\n}\n\nfunction assertExportNamespaceSpecifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExportNamespaceSpecifier\", node, opts);\n}\n\nfunction assertTSParameterProperty(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSParameterProperty\", node, opts);\n}\n\nfunction assertTSDeclareFunction(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSDeclareFunction\", node, opts);\n}\n\nfunction assertTSDeclareMethod(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSDeclareMethod\", node, opts);\n}\n\nfunction assertTSQualifiedName(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSQualifiedName\", node, opts);\n}\n\nfunction assertTSCallSignatureDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSCallSignatureDeclaration\", node, opts);\n}\n\nfunction assertTSConstructSignatureDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSConstructSignatureDeclaration\", node, opts);\n}\n\nfunction assertTSPropertySignature(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSPropertySignature\", node, opts);\n}\n\nfunction assertTSMethodSignature(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSMethodSignature\", node, opts);\n}\n\nfunction assertTSIndexSignature(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSIndexSignature\", node, opts);\n}\n\nfunction assertTSAnyKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSAnyKeyword\", node, opts);\n}\n\nfunction assertTSNumberKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSNumberKeyword\", node, opts);\n}\n\nfunction assertTSObjectKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSObjectKeyword\", node, opts);\n}\n\nfunction assertTSBooleanKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSBooleanKeyword\", node, opts);\n}\n\nfunction assertTSStringKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSStringKeyword\", node, opts);\n}\n\nfunction assertTSSymbolKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSSymbolKeyword\", node, opts);\n}\n\nfunction assertTSVoidKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSVoidKeyword\", node, opts);\n}\n\nfunction assertTSUndefinedKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSUndefinedKeyword\", node, opts);\n}\n\nfunction assertTSNullKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSNullKeyword\", node, opts);\n}\n\nfunction assertTSNeverKeyword(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSNeverKeyword\", node, opts);\n}\n\nfunction assertTSThisType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSThisType\", node, opts);\n}\n\nfunction assertTSFunctionType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSFunctionType\", node, opts);\n}\n\nfunction assertTSConstructorType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSConstructorType\", node, opts);\n}\n\nfunction assertTSTypeReference(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeReference\", node, opts);\n}\n\nfunction assertTSTypePredicate(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypePredicate\", node, opts);\n}\n\nfunction assertTSTypeQuery(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeQuery\", node, opts);\n}\n\nfunction assertTSTypeLiteral(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeLiteral\", node, opts);\n}\n\nfunction assertTSArrayType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSArrayType\", node, opts);\n}\n\nfunction assertTSTupleType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTupleType\", node, opts);\n}\n\nfunction assertTSUnionType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSUnionType\", node, opts);\n}\n\nfunction assertTSIntersectionType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSIntersectionType\", node, opts);\n}\n\nfunction assertTSConditionalType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSConditionalType\", node, opts);\n}\n\nfunction assertTSInferType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSInferType\", node, opts);\n}\n\nfunction assertTSParenthesizedType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSParenthesizedType\", node, opts);\n}\n\nfunction assertTSTypeOperator(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeOperator\", node, opts);\n}\n\nfunction assertTSIndexedAccessType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSIndexedAccessType\", node, opts);\n}\n\nfunction assertTSMappedType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSMappedType\", node, opts);\n}\n\nfunction assertTSLiteralType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSLiteralType\", node, opts);\n}\n\nfunction assertTSExpressionWithTypeArguments(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSExpressionWithTypeArguments\", node, opts);\n}\n\nfunction assertTSInterfaceDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSInterfaceDeclaration\", node, opts);\n}\n\nfunction assertTSInterfaceBody(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSInterfaceBody\", node, opts);\n}\n\nfunction assertTSTypeAliasDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeAliasDeclaration\", node, opts);\n}\n\nfunction assertTSAsExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSAsExpression\", node, opts);\n}\n\nfunction assertTSTypeAssertion(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeAssertion\", node, opts);\n}\n\nfunction assertTSEnumDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSEnumDeclaration\", node, opts);\n}\n\nfunction assertTSEnumMember(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSEnumMember\", node, opts);\n}\n\nfunction assertTSModuleDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSModuleDeclaration\", node, opts);\n}\n\nfunction assertTSModuleBlock(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSModuleBlock\", node, opts);\n}\n\nfunction assertTSImportEqualsDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSImportEqualsDeclaration\", node, opts);\n}\n\nfunction assertTSExternalModuleReference(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSExternalModuleReference\", node, opts);\n}\n\nfunction assertTSNonNullExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSNonNullExpression\", node, opts);\n}\n\nfunction assertTSExportAssignment(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSExportAssignment\", node, opts);\n}\n\nfunction assertTSNamespaceExportDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSNamespaceExportDeclaration\", node, opts);\n}\n\nfunction assertTSTypeAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeAnnotation\", node, opts);\n}\n\nfunction assertTSTypeParameterInstantiation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeParameterInstantiation\", node, opts);\n}\n\nfunction assertTSTypeParameterDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeParameterDeclaration\", node, opts);\n}\n\nfunction assertTSTypeParameter(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeParameter\", node, opts);\n}\n\nfunction assertExpression(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Expression\", node, opts);\n}\n\nfunction assertBinary(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Binary\", node, opts);\n}\n\nfunction assertScopable(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Scopable\", node, opts);\n}\n\nfunction assertBlockParent(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"BlockParent\", node, opts);\n}\n\nfunction assertBlock(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Block\", node, opts);\n}\n\nfunction assertStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Statement\", node, opts);\n}\n\nfunction assertTerminatorless(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Terminatorless\", node, opts);\n}\n\nfunction assertCompletionStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"CompletionStatement\", node, opts);\n}\n\nfunction assertConditional(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Conditional\", node, opts);\n}\n\nfunction assertLoop(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Loop\", node, opts);\n}\n\nfunction assertWhile(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"While\", node, opts);\n}\n\nfunction assertExpressionWrapper(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExpressionWrapper\", node, opts);\n}\n\nfunction assertFor(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"For\", node, opts);\n}\n\nfunction assertForXStatement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ForXStatement\", node, opts);\n}\n\nfunction assertFunction(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Function\", node, opts);\n}\n\nfunction assertFunctionParent(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"FunctionParent\", node, opts);\n}\n\nfunction assertPureish(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Pureish\", node, opts);\n}\n\nfunction assertDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Declaration\", node, opts);\n}\n\nfunction assertPatternLike(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"PatternLike\", node, opts);\n}\n\nfunction assertLVal(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"LVal\", node, opts);\n}\n\nfunction assertTSEntityName(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSEntityName\", node, opts);\n}\n\nfunction assertLiteral(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Literal\", node, opts);\n}\n\nfunction assertImmutable(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Immutable\", node, opts);\n}\n\nfunction assertUserWhitespacable(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"UserWhitespacable\", node, opts);\n}\n\nfunction assertMethod(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Method\", node, opts);\n}\n\nfunction assertObjectMember(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ObjectMember\", node, opts);\n}\n\nfunction assertProperty(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Property\", node, opts);\n}\n\nfunction assertUnaryLike(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"UnaryLike\", node, opts);\n}\n\nfunction assertPattern(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Pattern\", node, opts);\n}\n\nfunction assertClass(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Class\", node, opts);\n}\n\nfunction assertModuleDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ModuleDeclaration\", node, opts);\n}\n\nfunction assertExportDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ExportDeclaration\", node, opts);\n}\n\nfunction assertModuleSpecifier(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"ModuleSpecifier\", node, opts);\n}\n\nfunction assertFlow(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"Flow\", node, opts);\n}\n\nfunction assertFlowType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"FlowType\", node, opts);\n}\n\nfunction assertFlowBaseAnnotation(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"FlowBaseAnnotation\", node, opts);\n}\n\nfunction assertFlowDeclaration(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"FlowDeclaration\", node, opts);\n}\n\nfunction assertFlowPredicate(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"FlowPredicate\", node, opts);\n}\n\nfunction assertJSX(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"JSX\", node, opts);\n}\n\nfunction assertTSTypeElement(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSTypeElement\", node, opts);\n}\n\nfunction assertTSType(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  assert(\"TSType\", node, opts);\n}\n\nfunction assertNumberLiteral(node, opts) {\n  console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n  assert(\"NumberLiteral\", node, opts);\n}\n\nfunction assertRegexLiteral(node, opts) {\n  console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n  assert(\"RegexLiteral\", node, opts);\n}\n\nfunction assertRestProperty(node, opts) {\n  console.trace(\"The node type RestProperty has been renamed to RestElement\");\n  assert(\"RestProperty\", node, opts);\n}\n\nfunction assertSpreadProperty(node, opts) {\n  console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n  assert(\"SpreadProperty\", node, opts);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createTypeAnnotationBasedOnTypeof;\n\nvar _generated = require(\"../generated\");\n\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  if (type === \"string\") {\n    return (0, _generated.stringTypeAnnotation)();\n  } else if (type === \"number\") {\n    return (0, _generated.numberTypeAnnotation)();\n  } else if (type === \"undefined\") {\n    return (0, _generated.voidTypeAnnotation)();\n  } else if (type === \"boolean\") {\n    return (0, _generated.booleanTypeAnnotation)();\n  } else if (type === \"function\") {\n    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)(\"Function\"));\n  } else if (type === \"object\") {\n    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)(\"Object\"));\n  } else if (type === \"symbol\") {\n    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)(\"Symbol\"));\n  } else {\n    throw new Error(\"Invalid typeof value\");\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createUnionTypeAnnotation;\n\nvar _generated = require(\"../generated\");\n\nvar _removeTypeDuplicates = _interopRequireDefault(require(\"../../modifications/flow/removeTypeDuplicates\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createUnionTypeAnnotation(types) {\n  var flattened = (0, _removeTypeDuplicates.default)(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _generated.unionTypeAnnotation)(flattened);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\n\nvar _generated = require(\"../../validators/generated\");\n\nfunction removeTypeDuplicates(nodes) {\n  var generics = {};\n  var bases = {};\n  var typeGroups = [];\n  var types = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isFlowBaseAnnotation)(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if ((0, _generated.isUnionTypeAnnotation)(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isGenericTypeAnnotation)(node)) {\n      var name = node.id.name;\n\n      if (generics[name]) {\n        var existing = generics[name];\n\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (var type in bases) {\n    types.push(bases[type]);\n  }\n\n  for (var _name in generics) {\n    types.push(generics[_name]);\n  }\n\n  return types;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneNode;\n\nvar _definitions = require(\"../definitions\");\n\nvar has = Function.call.bind(Object.prototype.hasOwnProperty);\n\nfunction cloneIfNode(obj, deep) {\n  if (obj && typeof obj.type === \"string\" && obj.type !== \"CommentLine\" && obj.type !== \"CommentBlock\") {\n    return cloneNode(obj, deep);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(obj, deep) {\n  if (Array.isArray(obj)) {\n    return obj.map(function (node) {\n      return cloneIfNode(node, deep);\n    });\n  }\n\n  return cloneIfNode(obj, deep);\n}\n\nfunction cloneNode(node, deep) {\n  if (deep === void 0) {\n    deep = true;\n  }\n\n  if (!node) return node;\n  var type = node.type;\n  var newNode = {\n    type: type\n  };\n\n  if (type === \"Identifier\") {\n    newNode.name = node.name;\n  } else if (!has(_definitions.NODE_FIELDS, type)) {\n    throw new Error(\"Unknown node type: \\\"\" + type + \"\\\"\");\n  } else {\n    var _arr = Object.keys(_definitions.NODE_FIELDS[type]);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var field = _arr[_i];\n\n      if (has(node, field)) {\n        newNode[field] = deep ? cloneIfNodeOrArray(node[field], true) : node[field];\n      }\n    }\n  }\n\n  if (has(node, \"loc\")) {\n    newNode.loc = node.loc;\n  }\n\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = node.leadingComments;\n  }\n\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = node.innerCmments;\n  }\n\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = node.trailingComments;\n  }\n\n  if (has(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n\n  return newNode;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = clone;\n\nvar _cloneNode = _interopRequireDefault(require(\"./cloneNode\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction clone(node) {\n  return (0, _cloneNode.default)(node, false);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneDeep;\n\nvar _cloneNode = _interopRequireDefault(require(\"./cloneNode\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction cloneDeep(node) {\n  return (0, _cloneNode.default)(node);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneWithoutLoc;\n\nvar _clone = _interopRequireDefault(require(\"./clone\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction cloneWithoutLoc(node) {\n  var newNode = (0, _clone.default)(node);\n  newNode.loc = null;\n  return newNode;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = addComment;\n\nvar _addComments = _interopRequireDefault(require(\"./addComments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addComment(node, type, content, line) {\n  return (0, _addComments.default)(node, type, [{\n    type: line ? \"CommentLine\" : \"CommentBlock\",\n    value: content\n  }]);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = addComments;\n\nfunction addComments(node, type, comments) {\n  if (!comments || !node) return node;\n  var key = type + \"Comments\";\n\n  if (node[key]) {\n    if (type === \"leading\") {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key] = node[key].concat(comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n\n  return node;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritInnerComments;\n\nvar _inherit = _interopRequireDefault(require(\"../utils/inherit\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inheritInnerComments(child, parent) {\n  (0, _inherit.default)(\"innerComments\", child, parent);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inherit;\n\nfunction _uniq() {\n  var data = _interopRequireDefault(require(\"lodash/uniq\"));\n\n  _uniq = function _uniq() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inherit(key, child, parent) {\n  if (child && parent) {\n    child[key] = (0, _uniq().default)([].concat(child[key], parent[key]).filter(Boolean));\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritLeadingComments;\n\nvar _inherit = _interopRequireDefault(require(\"../utils/inherit\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inheritLeadingComments(child, parent) {\n  (0, _inherit.default)(\"leadingComments\", child, parent);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritsComments;\n\nvar _inheritTrailingComments = _interopRequireDefault(require(\"./inheritTrailingComments\"));\n\nvar _inheritLeadingComments = _interopRequireDefault(require(\"./inheritLeadingComments\"));\n\nvar _inheritInnerComments = _interopRequireDefault(require(\"./inheritInnerComments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inheritsComments(child, parent) {\n  (0, _inheritTrailingComments.default)(child, parent);\n  (0, _inheritLeadingComments.default)(child, parent);\n  (0, _inheritInnerComments.default)(child, parent);\n  return child;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritTrailingComments;\n\nvar _inherit = _interopRequireDefault(require(\"../utils/inherit\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inheritTrailingComments(child, parent) {\n  (0, _inherit.default)(\"trailingComments\", child, parent);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeComments;\n\nvar _constants = require(\"../constants\");\n\nfunction removeComments(node) {\n  _constants.COMMENT_KEYS.forEach(function (key) {\n    node[key] = null;\n  });\n\n  return node;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.JSX_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;\n\nvar _definitions = require(\"../../definitions\");\n\nvar EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Expression\"];\nexports.EXPRESSION_TYPES = EXPRESSION_TYPES;\nvar BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Binary\"];\nexports.BINARY_TYPES = BINARY_TYPES;\nvar SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Scopable\"];\nexports.SCOPABLE_TYPES = SCOPABLE_TYPES;\nvar BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"BlockParent\"];\nexports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;\nvar BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Block\"];\nexports.BLOCK_TYPES = BLOCK_TYPES;\nvar STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Statement\"];\nexports.STATEMENT_TYPES = STATEMENT_TYPES;\nvar TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Terminatorless\"];\nexports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;\nvar COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"CompletionStatement\"];\nexports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;\nvar CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Conditional\"];\nexports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;\nvar LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Loop\"];\nexports.LOOP_TYPES = LOOP_TYPES;\nvar WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"While\"];\nexports.WHILE_TYPES = WHILE_TYPES;\nvar EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ExpressionWrapper\"];\nexports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;\nvar FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"For\"];\nexports.FOR_TYPES = FOR_TYPES;\nvar FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ForXStatement\"];\nexports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;\nvar FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Function\"];\nexports.FUNCTION_TYPES = FUNCTION_TYPES;\nvar FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FunctionParent\"];\nexports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;\nvar PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Pureish\"];\nexports.PUREISH_TYPES = PUREISH_TYPES;\nvar DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Declaration\"];\nexports.DECLARATION_TYPES = DECLARATION_TYPES;\nvar PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"PatternLike\"];\nexports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;\nvar LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"LVal\"];\nexports.LVAL_TYPES = LVAL_TYPES;\nvar TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"TSEntityName\"];\nexports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;\nvar LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Literal\"];\nexports.LITERAL_TYPES = LITERAL_TYPES;\nvar IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Immutable\"];\nexports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;\nvar USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"UserWhitespacable\"];\nexports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;\nvar METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Method\"];\nexports.METHOD_TYPES = METHOD_TYPES;\nvar OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ObjectMember\"];\nexports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;\nvar PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Property\"];\nexports.PROPERTY_TYPES = PROPERTY_TYPES;\nvar UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"UnaryLike\"];\nexports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;\nvar PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Pattern\"];\nexports.PATTERN_TYPES = PATTERN_TYPES;\nvar CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Class\"];\nexports.CLASS_TYPES = CLASS_TYPES;\nvar MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ModuleDeclaration\"];\nexports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;\nvar EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ExportDeclaration\"];\nexports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;\nvar MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ModuleSpecifier\"];\nexports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;\nvar FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Flow\"];\nexports.FLOW_TYPES = FLOW_TYPES;\nvar FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FlowType\"];\nexports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;\nvar FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FlowBaseAnnotation\"];\nexports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;\nvar FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FlowDeclaration\"];\nexports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;\nvar FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FlowPredicate\"];\nexports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;\nvar JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"JSX\"];\nexports.JSX_TYPES = JSX_TYPES;\nvar TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"TSTypeElement\"];\nexports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;\nvar TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"TSType\"];\nexports.TSTYPE_TYPES = TSTYPE_TYPES;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ensureBlock;\n\nvar _toBlock = _interopRequireDefault(require(\"./toBlock\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ensureBlock(node, key) {\n  if (key === void 0) {\n    key = \"body\";\n  }\n\n  return node[key] = (0, _toBlock.default)(node[key], node);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toBlock;\n\nvar _generated = require(\"../validators/generated\");\n\nvar _generated2 = require(\"../builders/generated\");\n\nfunction toBlock(node, parent) {\n  if ((0, _generated.isBlockStatement)(node)) {\n    return node;\n  }\n\n  var blockNodes = [];\n\n  if ((0, _generated.isEmptyStatement)(node)) {\n    blockNodes = [];\n  } else {\n    if (!(0, _generated.isStatement)(node)) {\n      if ((0, _generated.isFunction)(parent)) {\n        node = (0, _generated2.returnStatement)(node);\n      } else {\n        node = (0, _generated2.expressionStatement)(node);\n      }\n    }\n\n    blockNodes = [node];\n  }\n\n  return (0, _generated2.blockStatement)(blockNodes);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toBindingIdentifierName;\n\nvar _toIdentifier = _interopRequireDefault(require(\"./toIdentifier\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toBindingIdentifierName(name) {\n  name = (0, _toIdentifier.default)(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n  return name;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toIdentifier;\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"../validators/isValidIdentifier\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toIdentifier(name) {\n  name = name + \"\";\n  name = name.replace(/[^a-zA-Z0-9$_]/g, \"-\");\n  name = name.replace(/^[-0-9]+/, \"\");\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!(0, _isValidIdentifier.default)(name)) {\n    name = \"_\" + name;\n  }\n\n  return name || \"_\";\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toComputedKey;\n\nvar _generated = require(\"../validators/generated\");\n\nvar _generated2 = require(\"../builders/generated\");\n\nfunction toComputedKey(node, key) {\n  if (key === void 0) {\n    key = node.key || node.property;\n  }\n\n  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);\n  return key;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toExpression;\n\nvar _generated = require(\"../validators/generated\");\n\nfunction toExpression(node) {\n  if ((0, _generated.isExpressionStatement)(node)) {\n    node = node.expression;\n  }\n\n  if ((0, _generated.isExpression)(node)) {\n    return node;\n  }\n\n  if ((0, _generated.isClass)(node)) {\n    node.type = \"ClassExpression\";\n  } else if ((0, _generated.isFunction)(node)) {\n    node.type = \"FunctionExpression\";\n  }\n\n  if (!(0, _generated.isExpression)(node)) {\n    throw new Error(\"cannot turn \" + node.type + \" to an expression\");\n  }\n\n  return node;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toKeyAlias;\n\nvar _generated = require(\"../validators/generated\");\n\nvar _cloneNode = _interopRequireDefault(require(\"../clone/cloneNode\"));\n\nvar _removePropertiesDeep = _interopRequireDefault(require(\"../modifications/removePropertiesDeep\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toKeyAlias(node, key) {\n  if (key === void 0) {\n    key = node.key;\n  }\n\n  var alias;\n\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if ((0, _generated.isIdentifier)(key)) {\n    alias = key.name;\n  } else if ((0, _generated.isStringLiteral)(key)) {\n    alias = JSON.stringify(key.value);\n  } else {\n    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));\n  }\n\n  if (node.computed) {\n    alias = \"[\" + alias + \"]\";\n  }\n\n  if (node.static) {\n    alias = \"static:\" + alias;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removePropertiesDeep;\n\nvar _traverseFast = _interopRequireDefault(require(\"../traverse/traverseFast\"));\n\nvar _removeProperties = _interopRequireDefault(require(\"./removeProperties\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction removePropertiesDeep(tree, opts) {\n  (0, _traverseFast.default)(tree, _removeProperties.default, opts);\n  return tree;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverseFast;\n\nvar _definitions = require(\"../definitions\");\n\nfunction traverseFast(node, enter, opts) {\n  if (!node) return;\n  var keys = _definitions.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  opts = opts || {};\n  enter(node, opts);\n\n  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var key = _ref;\n    var subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (var _iterator2 = subNode, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var _node = _ref2;\n        traverseFast(_node, enter, opts);\n      }\n    } else {\n      traverseFast(subNode, enter, opts);\n    }\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeProperties;\n\nvar _constants = require(\"../constants\");\n\nvar CLEAR_KEYS = [\"tokens\", \"start\", \"end\", \"loc\", \"raw\", \"rawValue\"];\n\nvar CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat([\"comments\"]).concat(CLEAR_KEYS);\n\nfunction removeProperties(node, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n\n  for (var _iterator = map, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _key = _ref;\n    if (node[_key] != null) node[_key] = undefined;\n  }\n\n  for (var key in node) {\n    if (key[0] === \"_\" && node[key] != null) node[key] = undefined;\n  }\n\n  var symbols = Object.getOwnPropertySymbols(node);\n\n  for (var _iterator2 = symbols, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref2 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref2 = _i2.value;\n    }\n\n    var sym = _ref2;\n    node[sym] = null;\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toSequenceExpression;\n\nvar _gatherSequenceExpressions = _interopRequireDefault(require(\"./gatherSequenceExpressions\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toSequenceExpression(nodes, scope) {\n  if (!nodes || !nodes.length) return;\n  var declars = [];\n  var result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);\n  if (!result) return;\n\n  for (var _i = 0; _i < declars.length; _i++) {\n    var declar = declars[_i];\n    scope.push(declar);\n  }\n\n  return result;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = gatherSequenceExpressions;\n\nvar _getBindingIdentifiers = _interopRequireDefault(require(\"../retrievers/getBindingIdentifiers\"));\n\nvar _generated = require(\"../validators/generated\");\n\nvar _generated2 = require(\"../builders/generated\");\n\nvar _cloneNode = _interopRequireDefault(require(\"../clone/cloneNode\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n  var exprs = [];\n  var ensureLastUndefined = true;\n\n  for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var node = _ref;\n    ensureLastUndefined = false;\n\n    if ((0, _generated.isExpression)(node)) {\n      exprs.push(node);\n    } else if ((0, _generated.isExpressionStatement)(node)) {\n      exprs.push(node.expression);\n    } else if ((0, _generated.isVariableDeclaration)(node)) {\n      if (node.kind !== \"var\") return;\n      var _arr = node.declarations;\n\n      for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n        var declar = _arr[_i2];\n        var bindings = (0, _getBindingIdentifiers.default)(declar);\n\n        for (var key in bindings) {\n          declars.push({\n            kind: node.kind,\n            id: (0, _cloneNode.default)(bindings[key])\n          });\n        }\n\n        if (declar.init) {\n          exprs.push((0, _generated2.assignmentExpression)(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if ((0, _generated.isIfStatement)(node)) {\n      var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();\n      var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return;\n      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));\n    } else if ((0, _generated.isBlockStatement)(node)) {\n      var body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if ((0, _generated.isEmptyStatement)(node)) {\n      ensureLastUndefined = true;\n    } else {\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return (0, _generated2.sequenceExpression)(exprs);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getBindingIdentifiers;\n\nvar _generated = require(\"../validators/generated\");\n\nfunction getBindingIdentifiers(node, duplicates, outerOnly) {\n  var search = [].concat(node);\n  var ids = Object.create(null);\n\n  while (search.length) {\n    var id = search.shift();\n    if (!id) continue;\n    var keys = getBindingIdentifiers.keys[id.type];\n\n    if ((0, _generated.isIdentifier)(id)) {\n      if (duplicates) {\n        var _ids = ids[id.name] = ids[id.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isExportDeclaration)(id)) {\n      if ((0, _generated.isDeclaration)(id.declaration)) {\n        search.push(id.declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if ((0, _generated.isFunctionDeclaration)(id)) {\n        search.push(id.id);\n        continue;\n      }\n\n      if ((0, _generated.isFunctionExpression)(id)) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n\n        if (id[key]) {\n          search = search.concat(id[key]);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\ngetBindingIdentifiers.keys = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n  OpaqueType: [\"id\"],\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n  ExportSpecifier: [\"exported\"],\n  ExportNamespaceSpecifier: [\"exported\"],\n  ExportDefaultSpecifier: [\"exported\"],\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n  ArrowFunctionExpression: [\"params\"],\n  ObjectMethod: [\"params\"],\n  ClassMethod: [\"params\"],\n  ForInStatement: [\"left\"],\n  ForOfStatement: [\"left\"],\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n  ObjectProperty: [\"value\"],\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"]\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toStatement;\n\nvar _generated = require(\"../validators/generated\");\n\nvar _generated2 = require(\"../builders/generated\");\n\nfunction toStatement(node, ignore) {\n  if ((0, _generated.isStatement)(node)) {\n    return node;\n  }\n\n  var mustHaveId = false;\n  var newType;\n\n  if ((0, _generated.isClass)(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if ((0, _generated.isFunction)(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if ((0, _generated.isAssignmentExpression)(node)) {\n    return (0, _generated2.expressionStatement)(node);\n  }\n\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(\"cannot turn \" + node.type + \" to a statement\");\n    }\n  }\n\n  node.type = newType;\n  return node;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = valueToNode;\n\nfunction _isPlainObject() {\n  var data = _interopRequireDefault(require(\"lodash/isPlainObject\"));\n\n  _isPlainObject = function _isPlainObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _isRegExp() {\n  var data = _interopRequireDefault(require(\"lodash/isRegExp\"));\n\n  _isRegExp = function _isRegExp() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"../validators/isValidIdentifier\"));\n\nvar _generated = require(\"../builders/generated\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return (0, _generated.identifier)(\"undefined\");\n  }\n\n  if (value === true || value === false) {\n    return (0, _generated.booleanLiteral)(value);\n  }\n\n  if (value === null) {\n    return (0, _generated.nullLiteral)();\n  }\n\n  if (typeof value === \"string\") {\n    return (0, _generated.stringLiteral)(value);\n  }\n\n  if (typeof value === \"number\") {\n    return (0, _generated.numericLiteral)(value);\n  }\n\n  if ((0, _isRegExp().default)(value)) {\n    var pattern = value.source;\n    var flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return (0, _generated.regExpLiteral)(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return (0, _generated.arrayExpression)(value.map(valueToNode));\n  }\n\n  if ((0, _isPlainObject().default)(value)) {\n    var props = [];\n\n    for (var key in value) {\n      var nodeKey = void 0;\n\n      if ((0, _isValidIdentifier.default)(key)) {\n        nodeKey = (0, _generated.identifier)(key);\n      } else {\n        nodeKey = (0, _generated.stringLiteral)(key);\n      }\n\n      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));\n    }\n\n    return (0, _generated.objectExpression)(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = appendToMemberExpression;\n\nvar _generated = require(\"../builders/generated\");\n\nfunction appendToMemberExpression(member, append, computed) {\n  if (computed === void 0) {\n    computed = false;\n  }\n\n  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);\n  member.property = append;\n  member.computed = !!computed;\n  return member;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inherits;\n\nvar _constants = require(\"../constants\");\n\nvar _inheritsComments = _interopRequireDefault(require(\"../comments/inheritsComments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inherits(child, parent) {\n  if (!child || !parent) return child;\n  var _arr = _constants.INHERIT_KEYS.optional;\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var _key = _arr[_i];\n\n    if (child[_key] == null) {\n      child[_key] = parent[_key];\n    }\n  }\n\n  for (var key in parent) {\n    if (key[0] === \"_\" && key !== \"__clone\") child[key] = parent[key];\n  }\n\n  var _arr2 = _constants.INHERIT_KEYS.force;\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var _key2 = _arr2[_i2];\n    child[_key2] = parent[_key2];\n  }\n\n  (0, _inheritsComments.default)(child, parent);\n  return child;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = prependToMemberExpression;\n\nvar _generated = require(\"../builders/generated\");\n\nfunction prependToMemberExpression(member, prepend) {\n  member.object = (0, _generated.memberExpression)(prepend, member.object);\n  return member;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getOuterBindingIdentifiers;\n\nvar _getBindingIdentifiers = _interopRequireDefault(require(\"./getBindingIdentifiers\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOuterBindingIdentifiers(node, duplicates) {\n  return (0, _getBindingIdentifiers.default)(node, duplicates, true);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverse;\n\nvar _definitions = require(\"../definitions\");\n\nfunction traverse(node, handlers, state) {\n  if (typeof handlers === \"function\") {\n    handlers = {\n      enter: handlers\n    };\n  }\n\n  var _ref = handlers,\n      enter = _ref.enter,\n      exit = _ref.exit;\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\n\nfunction traverseSimpleImpl(node, enter, exit, state, ancestors) {\n  var keys = _definitions.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  if (enter) enter(node, ancestors, state);\n\n  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref2 = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref2 = _i.value;\n    }\n\n    var _key = _ref2;\n    var subNode = node[_key];\n\n    if (Array.isArray(subNode)) {\n      for (var i = 0; i < subNode.length; i++) {\n        var child = subNode[i];\n        if (!child) continue;\n        ancestors.push({\n          node: node,\n          key: _key,\n          index: i\n        });\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node: node,\n        key: _key\n      });\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n      ancestors.pop();\n    }\n  }\n\n  if (exit) exit(node, ancestors, state);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBinding;\n\nvar _getBindingIdentifiers = _interopRequireDefault(require(\"../retrievers/getBindingIdentifiers\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isBinding(node, parent) {\n  var keys = _getBindingIdentifiers.default.keys[parent.type];\n\n  if (keys) {\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = parent[key];\n\n      if (Array.isArray(val)) {\n        if (val.indexOf(node) >= 0) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n\n  return false;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBlockScoped;\n\nvar _generated = require(\"./generated\");\n\nvar _isLet = _interopRequireDefault(require(\"./isLet\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isBlockScoped(node) {\n  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isLet;\n\nvar _generated = require(\"./generated\");\n\nvar _constants = require(\"../constants\");\n\nfunction isLet(node) {\n  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== \"var\" || node[_constants.BLOCK_SCOPED_SYMBOL]);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isImmutable;\n\nvar _isType = _interopRequireDefault(require(\"./isType\"));\n\nvar _generated = require(\"./generated\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isImmutable(node) {\n  if ((0, _isType.default)(node.type, \"Immutable\")) return true;\n\n  if ((0, _generated.isIdentifier)(node)) {\n    if (node.name === \"undefined\") {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isNodesEquivalent;\n\nvar _definitions = require(\"../definitions\");\n\nfunction isNodesEquivalent(a, b) {\n  if (typeof a !== \"object\" || typeof b !== \"object\" || a == null || b == null) {\n    return a === b;\n  }\n\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  var fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);\n\n  for (var _i = 0; _i < fields.length; _i++) {\n    var field = fields[_i];\n\n    if (typeof a[field] !== typeof b[field]) {\n      return false;\n    }\n\n    if (Array.isArray(a[field])) {\n      if (!Array.isArray(b[field])) {\n        return false;\n      }\n\n      if (a[field].length !== b[field].length) {\n        return false;\n      }\n\n      for (var i = 0; i < a[field].length; i++) {\n        if (!isNodesEquivalent(a[field][i], b[field][i])) {\n          return false;\n        }\n      }\n\n      continue;\n    }\n\n    if (!isNodesEquivalent(a[field], b[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isReferenced;\n\nfunction isReferenced(node, parent) {\n  switch (parent.type) {\n    case \"BindExpression\":\n      return parent.object === node || parent.callee === node;\n\n    case \"MemberExpression\":\n    case \"JSXMemberExpression\":\n      if (parent.property === node && parent.computed) {\n        return true;\n      } else if (parent.object === node) {\n        return true;\n      } else {\n        return false;\n      }\n\n    case \"MetaProperty\":\n      return false;\n\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return parent.computed;\n      }\n\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    case \"ArrowFunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      var _arr = parent.params;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var param = _arr[_i];\n        if (param === node) return false;\n      }\n\n      return parent.id !== node;\n\n    case \"ExportSpecifier\":\n      if (parent.source) {\n        return false;\n      } else {\n        return parent.local === node;\n      }\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n\n    case \"JSXAttribute\":\n      return parent.name !== node;\n\n    case \"ClassProperty\":\n      if (parent.key === node) {\n        return parent.computed;\n      } else {\n        return parent.value === node;\n      }\n\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.id !== node;\n\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n      return parent.key === node && parent.computed;\n\n    case \"LabeledStatement\":\n      return false;\n\n    case \"CatchClause\":\n      return parent.param !== node;\n\n    case \"RestElement\":\n      return false;\n\n    case \"AssignmentExpression\":\n      return parent.right === node;\n\n    case \"AssignmentPattern\":\n      return parent.right === node;\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n  }\n\n  return true;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isScope;\n\nvar _generated = require(\"./generated\");\n\nfunction isScope(node, parent) {\n  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isFunction)(parent, {\n    body: node\n  })) {\n    return false;\n  }\n\n  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isCatchClause)(parent, {\n    body: node\n  })) {\n    return false;\n  }\n\n  return (0, _generated.isScopable)(node);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isSpecifierDefault;\n\nvar _generated = require(\"./generated\");\n\nfunction isSpecifierDefault(specifier) {\n  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {\n    name: \"default\"\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isValidES3Identifier;\n\nvar _isValidIdentifier = _interopRequireDefault(require(\"./isValidIdentifier\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar RESERVED_WORDS_ES3_ONLY = new Set([\"abstract\", \"boolean\", \"byte\", \"char\", \"double\", \"enum\", \"final\", \"float\", \"goto\", \"implements\", \"int\", \"interface\", \"long\", \"native\", \"package\", \"private\", \"protected\", \"public\", \"short\", \"static\", \"synchronized\", \"throws\", \"transient\", \"volatile\"]);\n\nfunction isValidES3Identifier(name) {\n  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isVar;\n\nvar _generated = require(\"./generated\");\n\nvar _constants = require(\"../constants\");\n\nfunction isVar(node) {\n  return (0, _generated.isVariableDeclaration)(node, {\n    kind: \"var\"\n  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];\n}"]}