{"version":3,"sources":["index.js","transformer-legacy.js","transformer-2021-12.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxDecorators = require(\"@babel/plugin-syntax-decorators\");\n\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\n\nvar _transformerLegacy = require(\"./transformer-legacy\");\n\nvar _transformer = require(\"./transformer-2021-12\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    legacy,\n    version\n  } = options;\n\n  if (legacy || version === \"legacy\") {\n    return {\n      name: \"proposal-decorators\",\n      inherits: _pluginSyntaxDecorators.default,\n      visitor: _transformerLegacy.default\n    };\n  } else if (version === \"2021-12\") {\n    return (0, _transformer.default)(api, options);\n  } else {\n    return (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({\n      name: \"proposal-decorators\",\n      api,\n      feature: _helperCreateClassFeaturesPlugin.FEATURES.decorators,\n      inherits: _pluginSyntaxDecorators.default\n    });\n  }\n});\n\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nconst buildClassDecorator = (0, _core.template)(`\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n`);\nconst buildClassPrototype = (0, _core.template)(`\n  CLASS_REF.prototype;\n`);\nconst buildGetDescriptor = (0, _core.template)(`\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n`);\nconst buildGetObjectInitializer = (0, _core.template)(`\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n`);\nconst WARNING_CALLS = new WeakSet();\n\nfunction applyEnsureOrdering(path) {\n  const decorators = (path.isClass() ? [path].concat(path.get(\"body.body\")) : path.get(\"properties\")).reduce((acc, prop) => acc.concat(prop.node.decorators || []), []);\n  const identDecorators = decorators.filter(decorator => !_core.types.isIdentifier(decorator.expression));\n  if (identDecorators.length === 0) return;\n  return _core.types.sequenceExpression(identDecorators.map(decorator => {\n    const expression = decorator.expression;\n    const id = decorator.expression = path.scope.generateDeclaredUidIdentifier(\"dec\");\n    return _core.types.assignmentExpression(\"=\", id, expression);\n  }).concat([path.node]));\n}\n\nfunction applyClassDecorators(classPath) {\n  if (!hasClassDecorators(classPath.node)) return;\n  const decorators = classPath.node.decorators || [];\n  classPath.node.decorators = null;\n  const name = classPath.scope.generateDeclaredUidIdentifier(\"class\");\n  return decorators.map(dec => dec.expression).reverse().reduce(function (acc, decorator) {\n    return buildClassDecorator({\n      CLASS_REF: _core.types.cloneNode(name),\n      DECORATOR: _core.types.cloneNode(decorator),\n      INNER: acc\n    }).expression;\n  }, classPath.node);\n}\n\nfunction hasClassDecorators(classNode) {\n  return !!(classNode.decorators && classNode.decorators.length);\n}\n\nfunction applyMethodDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.body.body)) return;\n  return applyTargetDecorators(path, state, path.node.body.body);\n}\n\nfunction hasMethodDecorators(body) {\n  return body.some(node => {\n    var _node$decorators;\n\n    return (_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length;\n  });\n}\n\nfunction applyObjectDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.properties)) return;\n  return applyTargetDecorators(path, state, path.node.properties);\n}\n\nfunction applyTargetDecorators(path, state, decoratedProps) {\n  const name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? \"class\" : \"obj\");\n  const exprs = decoratedProps.reduce(function (acc, node) {\n    const decorators = node.decorators || [];\n    node.decorators = null;\n    if (decorators.length === 0) return acc;\n\n    if (node.computed) {\n      throw path.buildCodeFrameError(\"Computed method/property decorators are not yet supported.\");\n    }\n\n    const property = _core.types.isLiteral(node.key) ? node.key : _core.types.stringLiteral(node.key.name);\n    const target = path.isClass() && !node.static ? buildClassPrototype({\n      CLASS_REF: name\n    }).expression : name;\n\n    if (_core.types.isClassProperty(node, {\n      static: false\n    })) {\n      const descriptor = path.scope.generateDeclaredUidIdentifier(\"descriptor\");\n      const initializer = node.value ? _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(node.value)])) : _core.types.nullLiteral();\n      node.value = _core.types.callExpression(state.addHelper(\"initializerWarningHelper\"), [descriptor, _core.types.thisExpression()]);\n      WARNING_CALLS.add(node.value);\n      acc.push(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(descriptor), _core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"configurable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"enumerable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"writable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"initializer\"), initializer)])])));\n    } else {\n      acc.push(_core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.isObjectProperty(node) || _core.types.isClassProperty(node, {\n        static: true\n      }) ? buildGetObjectInitializer({\n        TEMP: path.scope.generateDeclaredUidIdentifier(\"init\"),\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression : buildGetDescriptor({\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression, _core.types.cloneNode(target)]));\n    }\n\n    return acc;\n  }, []);\n  return _core.types.sequenceExpression([_core.types.assignmentExpression(\"=\", _core.types.cloneNode(name), path.node), _core.types.sequenceExpression(exprs), _core.types.cloneNode(name)]);\n}\n\nfunction decoratedClassToExpression({\n  node,\n  scope\n}) {\n  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {\n    return;\n  }\n\n  const ref = node.id ? _core.types.cloneNode(node.id) : scope.generateUidIdentifier(\"class\");\n  return _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]);\n}\n\nvar _default = {\n  ExportDefaultDeclaration(path) {\n    const decl = path.get(\"declaration\");\n    if (!decl.isClassDeclaration()) return;\n    const replacement = decoratedClassToExpression(decl);\n\n    if (replacement) {\n      const [varDeclPath] = path.replaceWithMultiple([replacement, _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(replacement.declarations[0].id), _core.types.identifier(\"default\"))])]);\n\n      if (!decl.node.id) {\n        path.scope.registerDeclaration(varDeclPath);\n      }\n    }\n  },\n\n  ClassDeclaration(path) {\n    const replacement = decoratedClassToExpression(path);\n\n    if (replacement) {\n      path.replaceWith(replacement);\n    }\n  },\n\n  ClassExpression(path, state) {\n    const decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);\n    if (decoratedClass) path.replaceWith(decoratedClass);\n  },\n\n  ObjectExpression(path, state) {\n    const decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);\n    if (decoratedObject) path.replaceWith(decoratedObject);\n  },\n\n  AssignmentExpression(path, state) {\n    if (!WARNING_CALLS.has(path.node.right)) return;\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"left.object\").node), _core.types.stringLiteral(path.get(\"left.property\").node.name || path.get(\"left.property\").node.value), _core.types.cloneNode(path.get(\"right.arguments\")[0].node), _core.types.cloneNode(path.get(\"right.arguments\")[1].node)]));\n  },\n\n  CallExpression(path, state) {\n    if (path.node.arguments.length !== 3) return;\n    if (!WARNING_CALLS.has(path.node.arguments[2])) return;\n\n    if (path.node.callee.name !== state.addHelper(\"defineProperty\").name) {\n      return;\n    }\n\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments\")[1].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[1].node)]));\n  }\n\n};\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _core = require(\"@babel/core\");\n\nvar _pluginSyntaxDecorators = require(\"@babel/plugin-syntax-decorators\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nfunction incrementId(id, idx = id.length - 1) {\n  if (idx === -1) {\n    id.unshift(65);\n    return;\n  }\n\n  const current = id[idx];\n\n  if (current === 90) {\n    id[idx] = 97;\n  } else if (current === 122) {\n    id[idx] = 65;\n    incrementId(id, idx - 1);\n  } else {\n    id[idx] = current + 1;\n  }\n}\n\nfunction createPrivateUidGeneratorForClass(classPath) {\n  const currentPrivateId = [];\n  const privateNames = new Set();\n  classPath.traverse({\n    PrivateName(path) {\n      privateNames.add(path.node.id.name);\n    }\n\n  });\n  return () => {\n    let reifiedId;\n\n    do {\n      incrementId(currentPrivateId);\n      reifiedId = String.fromCharCode(...currentPrivateId);\n    } while (privateNames.has(reifiedId));\n\n    return _core.types.privateName(_core.types.identifier(reifiedId));\n  };\n}\n\nfunction createLazyPrivateUidGeneratorForClass(classPath) {\n  let generator;\n  return () => {\n    if (!generator) {\n      generator = createPrivateUidGeneratorForClass(classPath);\n    }\n\n    return generator();\n  };\n}\n\nfunction replaceClassWithVar(path) {\n  if (path.type === \"ClassDeclaration\") {\n    const varId = path.scope.generateUidIdentifierBasedOnNode(path.node.id);\n\n    const classId = _core.types.identifier(path.node.id.name);\n\n    path.scope.rename(classId.name, varId.name);\n    path.insertBefore(_core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(varId)]));\n    path.get(\"id\").replaceWith(classId);\n    return [_core.types.cloneNode(varId), path];\n  } else {\n    let className;\n    let varId;\n\n    if (path.node.id) {\n      className = path.node.id.name;\n      varId = path.scope.parent.generateDeclaredUidIdentifier(className);\n      path.scope.rename(className, varId.name);\n    } else if (path.parentPath.node.type === \"VariableDeclarator\" && path.parentPath.node.id.type === \"Identifier\") {\n      className = path.parentPath.node.id.name;\n      varId = path.scope.parent.generateDeclaredUidIdentifier(className);\n    } else {\n      varId = path.scope.parent.generateDeclaredUidIdentifier(\"decorated_class\");\n    }\n\n    const newClassExpr = _core.types.classExpression(className && _core.types.identifier(className), path.node.superClass, path.node.body);\n\n    const [newPath] = path.replaceWith(_core.types.sequenceExpression([newClassExpr, varId]));\n    return [_core.types.cloneNode(varId), newPath.get(\"expressions.0\")];\n  }\n}\n\nfunction generateClassProperty(key, value, isStatic) {\n  if (key.type === \"PrivateName\") {\n    return _core.types.classPrivateProperty(key, value, undefined, isStatic);\n  } else {\n    return _core.types.classProperty(key, value, undefined, undefined, isStatic);\n  }\n}\n\nfunction addProxyAccessorsFor(element, originalKey, targetKey, isComputed = false) {\n  const {\n    static: isStatic\n  } = element.node;\n\n  const getterBody = _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.thisExpression(), _core.types.cloneNode(targetKey)))]);\n\n  const setterBody = _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.thisExpression(), _core.types.cloneNode(targetKey)), _core.types.identifier(\"v\")))]);\n\n  let getter, setter;\n\n  if (originalKey.type === \"PrivateName\") {\n    getter = _core.types.classPrivateMethod(\"get\", _core.types.cloneNode(originalKey), [], getterBody, isStatic);\n    setter = _core.types.classPrivateMethod(\"set\", _core.types.cloneNode(originalKey), [_core.types.identifier(\"v\")], setterBody, isStatic);\n  } else {\n    getter = _core.types.classMethod(\"get\", _core.types.cloneNode(originalKey), [], getterBody, isComputed, isStatic);\n    setter = _core.types.classMethod(\"set\", _core.types.cloneNode(originalKey), [_core.types.identifier(\"v\")], setterBody, isComputed, isStatic);\n  }\n\n  element.insertAfter(setter);\n  element.insertAfter(getter);\n}\n\nfunction extractProxyAccessorsFor(targetKey) {\n  return [_core.types.functionExpression(undefined, [], _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.thisExpression(), _core.types.cloneNode(targetKey)))])), _core.types.functionExpression(undefined, [_core.types.identifier(\"value\")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.thisExpression(), _core.types.cloneNode(targetKey)), _core.types.identifier(\"value\")))]))];\n}\n\nconst FIELD = 0;\nconst ACCESSOR = 1;\nconst METHOD = 2;\nconst GETTER = 3;\nconst SETTER = 4;\nconst STATIC = 5;\n\nfunction getElementKind(element) {\n  switch (element.node.type) {\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n      return FIELD;\n\n    case \"ClassAccessorProperty\":\n      return ACCESSOR;\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (element.node.kind === \"get\") {\n        return GETTER;\n      } else if (element.node.kind === \"set\") {\n        return SETTER;\n      } else {\n        return METHOD;\n      }\n\n  }\n}\n\nfunction isDecoratorInfo(info) {\n  return \"decorators\" in info;\n}\n\nfunction filteredOrderedDecoratorInfo(info) {\n  const filtered = info.filter(isDecoratorInfo);\n  return [...filtered.filter(el => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...filtered.filter(el => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...filtered.filter(el => el.isStatic && el.kind === FIELD), ...filtered.filter(el => !el.isStatic && el.kind === FIELD)];\n}\n\nfunction generateDecorationExprs(info) {\n  return _core.types.arrayExpression(filteredOrderedDecoratorInfo(info).map(el => {\n    const decs = el.decorators.length > 1 ? _core.types.arrayExpression(el.decorators) : el.decorators[0];\n    const kind = el.isStatic ? el.kind + STATIC : el.kind;\n    const decInfo = [decs, _core.types.numericLiteral(kind), el.name];\n    const {\n      privateMethods\n    } = el;\n\n    if (Array.isArray(privateMethods)) {\n      decInfo.push(...privateMethods);\n    } else if (privateMethods) {\n      decInfo.push(privateMethods);\n    }\n\n    return _core.types.arrayExpression(decInfo);\n  }));\n}\n\nfunction extractElementLocalAssignments(decorationInfo) {\n  const localIds = [];\n\n  for (const el of filteredOrderedDecoratorInfo(decorationInfo)) {\n    const {\n      locals\n    } = el;\n\n    if (Array.isArray(locals)) {\n      localIds.push(...locals);\n    } else if (locals !== undefined) {\n      localIds.push(locals);\n    }\n  }\n\n  return localIds;\n}\n\nfunction addCallAccessorsFor(element, key, getId, setId) {\n  element.insertAfter(_core.types.classPrivateMethod(\"get\", _core.types.cloneNode(key), [], _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.cloneNode(getId), [_core.types.thisExpression()]))])));\n  element.insertAfter(_core.types.classPrivateMethod(\"set\", _core.types.cloneNode(key), [_core.types.identifier(\"v\")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(setId), [_core.types.thisExpression(), _core.types.identifier(\"v\")]))])));\n}\n\nfunction isNotTsParameter(node) {\n  return node.type !== \"TSParameterProperty\";\n}\n\nfunction movePrivateAccessor(element, key, methodLocalVar, isStatic) {\n  let params;\n  let block;\n\n  if (element.node.kind === \"set\") {\n    params = [_core.types.identifier(\"v\")];\n    block = [_core.types.expressionStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression(), _core.types.identifier(\"v\")]))];\n  } else {\n    params = [];\n    block = [_core.types.returnStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression()]))];\n  }\n\n  element.replaceWith(_core.types.classPrivateMethod(element.node.kind, _core.types.cloneNode(key), params, _core.types.blockStatement(block), isStatic));\n}\n\nfunction isClassDecoratableElementPath(path) {\n  const {\n    type\n  } = path;\n  return type !== \"TSDeclareMethod\" && type !== \"TSIndexSignature\" && type !== \"StaticBlock\";\n}\n\nfunction staticBlockToIIFE(block) {\n  return _core.types.callExpression(_core.types.arrowFunctionExpression([], _core.types.blockStatement(block.body)), []);\n}\n\nfunction maybeSequenceExpression(exprs) {\n  if (exprs.length === 0) return _core.types.unaryExpression(\"void\", _core.types.numericLiteral(0));\n  if (exprs.length === 1) return exprs[0];\n  return _core.types.sequenceExpression(exprs);\n}\n\nfunction transformClass(path, state, constantSuper) {\n  const body = path.get(\"body.body\");\n  const classDecorators = path.node.decorators;\n  let hasElementDecorators = false;\n  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);\n\n  for (const element of body) {\n    if (!isClassDecoratableElementPath(element)) {\n      continue;\n    }\n\n    if (element.node.decorators && element.node.decorators.length > 0) {\n      hasElementDecorators = true;\n    } else if (element.node.type === \"ClassAccessorProperty\") {\n      const {\n        key,\n        value,\n        static: isStatic\n      } = element.node;\n      const newId = generateClassPrivateUid();\n      const valueNode = value ? _core.types.cloneNode(value) : undefined;\n      const newField = generateClassProperty(newId, valueNode, isStatic);\n      const [newPath] = element.replaceWith(newField);\n      addProxyAccessorsFor(newPath, key, newId, element.node.computed);\n    }\n  }\n\n  if (!classDecorators && !hasElementDecorators) return;\n  const elementDecoratorInfo = [];\n  let firstFieldPath;\n  let constructorPath;\n  let requiresProtoInit = false;\n  let requiresStaticInit = false;\n  const decoratedPrivateMethods = new Set();\n  let protoInitLocal, staticInitLocal, classInitLocal, classLocal;\n  const assignments = [];\n  const scopeParent = path.scope.parent;\n\n  const memoiseExpression = (expression, hint) => {\n    const localEvaluatedId = scopeParent.generateDeclaredUidIdentifier(hint);\n    assignments.push(_core.types.assignmentExpression(\"=\", localEvaluatedId, expression));\n    return _core.types.cloneNode(localEvaluatedId);\n  };\n\n  if (classDecorators) {\n    classInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initClass\");\n    const [localId, classPath] = replaceClassWithVar(path);\n    path = classPath;\n    classLocal = localId;\n    path.node.decorators = null;\n\n    for (const classDecorator of classDecorators) {\n      if (!scopeParent.isStatic(classDecorator.expression)) {\n        classDecorator.expression = memoiseExpression(classDecorator.expression, \"dec\");\n      }\n    }\n  } else {\n    if (!path.node.id) {\n      path.node.id = path.scope.generateUidIdentifier(\"Class\");\n    }\n\n    classLocal = _core.types.cloneNode(path.node.id);\n  }\n\n  if (hasElementDecorators) {\n    for (const element of body) {\n      if (!isClassDecoratableElementPath(element)) {\n        continue;\n      }\n\n      const {\n        node\n      } = element;\n      const decorators = element.get(\"decorators\");\n      const hasDecorators = Array.isArray(decorators) && decorators.length > 0;\n\n      if (hasDecorators) {\n        for (const decoratorPath of decorators) {\n          if (!scopeParent.isStatic(decoratorPath.node.expression)) {\n            decoratorPath.node.expression = memoiseExpression(decoratorPath.node.expression, \"dec\");\n          }\n        }\n      }\n\n      const isComputed = \"computed\" in element.node && element.node.computed === true;\n\n      if (isComputed) {\n        if (!scopeParent.isStatic(node.key)) {\n          node.key = memoiseExpression(node.key, \"computedKey\");\n        }\n      }\n\n      const kind = getElementKind(element);\n      const {\n        key\n      } = node;\n      const isPrivate = key.type === \"PrivateName\";\n      const isStatic = !!element.node.static;\n      let name = \"computedKey\";\n\n      if (isPrivate) {\n        name = key.id.name;\n      } else if (!isComputed && key.type === \"Identifier\") {\n        name = key.name;\n      }\n\n      if (element.isClassMethod({\n        kind: \"constructor\"\n      })) {\n        constructorPath = element;\n      }\n\n      if (hasDecorators) {\n        let locals;\n        let privateMethods;\n\n        if (kind === ACCESSOR) {\n          const {\n            value\n          } = element.node;\n          const params = [_core.types.thisExpression()];\n\n          if (value) {\n            params.push(_core.types.cloneNode(value));\n          }\n\n          const newId = generateClassPrivateUid();\n          const newFieldInitId = element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);\n\n          const newValue = _core.types.callExpression(_core.types.cloneNode(newFieldInitId), params);\n\n          const newField = generateClassProperty(newId, newValue, isStatic);\n          const [newPath] = element.replaceWith(newField);\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(newId);\n            const getId = newPath.scope.parent.generateDeclaredUidIdentifier(`get_${name}`);\n            const setId = newPath.scope.parent.generateDeclaredUidIdentifier(`set_${name}`);\n            addCallAccessorsFor(newPath, key, getId, setId);\n            locals = [newFieldInitId, getId, setId];\n          } else {\n            addProxyAccessorsFor(newPath, key, newId, isComputed);\n            locals = newFieldInitId;\n          }\n        } else if (kind === FIELD) {\n          const initId = element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);\n          const valuePath = element.get(\"value\");\n          valuePath.replaceWith(_core.types.callExpression(_core.types.cloneNode(initId), [_core.types.thisExpression(), valuePath.node].filter(v => v)));\n          locals = initId;\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(key);\n          }\n        } else if (isPrivate) {\n          locals = element.scope.parent.generateDeclaredUidIdentifier(`call_${name}`);\n          const replaceSupers = new _helperReplaceSupers.default({\n            constantSuper,\n            methodPath: element,\n            objectRef: classLocal,\n            superRef: path.node.superClass,\n            file: state,\n            refToPreserve: classLocal\n          });\n          replaceSupers.replace();\n          const {\n            params,\n            body,\n            async: isAsync\n          } = element.node;\n          privateMethods = _core.types.functionExpression(undefined, params.filter(isNotTsParameter), body, isAsync);\n\n          if (kind === GETTER || kind === SETTER) {\n            movePrivateAccessor(element, _core.types.cloneNode(key), _core.types.cloneNode(locals), isStatic);\n          } else {\n            const node = element.node;\n            path.node.body.body.unshift(_core.types.classPrivateProperty(key, _core.types.cloneNode(locals), [], node.static));\n            decoratedPrivateMethods.add(key.id.name);\n            element.remove();\n          }\n        }\n\n        let nameExpr;\n\n        if (isComputed) {\n          nameExpr = _core.types.cloneNode(key);\n        } else if (key.type === \"PrivateName\") {\n          nameExpr = _core.types.stringLiteral(key.id.name);\n        } else if (key.type === \"Identifier\") {\n          nameExpr = _core.types.stringLiteral(key.name);\n        } else {\n          nameExpr = _core.types.cloneNode(key);\n        }\n\n        elementDecoratorInfo.push({\n          kind,\n          decorators: decorators.map(d => d.node.expression),\n          name: nameExpr,\n          isStatic,\n          privateMethods,\n          locals\n        });\n\n        if (kind !== FIELD) {\n          if (isStatic) {\n            requiresStaticInit = true;\n          } else {\n            requiresProtoInit = true;\n          }\n        }\n\n        if (element.node) {\n          element.node.decorators = null;\n        }\n\n        if (!firstFieldPath && (kind === FIELD || kind === ACCESSOR)) {\n          firstFieldPath = element;\n        }\n      }\n    }\n  }\n\n  const elementDecorations = generateDecorationExprs(elementDecoratorInfo);\n\n  const classDecorations = _core.types.arrayExpression((classDecorators || []).map(d => d.expression));\n\n  const locals = extractElementLocalAssignments(elementDecoratorInfo);\n\n  if (requiresProtoInit) {\n    protoInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initProto\");\n    locals.push(protoInitLocal);\n\n    const protoInitCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [_core.types.thisExpression()]);\n\n    if (firstFieldPath) {\n      const value = firstFieldPath.get(\"value\");\n      const body = [protoInitCall];\n\n      if (value.node) {\n        body.push(value.node);\n      }\n\n      value.replaceWith(_core.types.sequenceExpression(body));\n    } else if (constructorPath) {\n      if (path.node.superClass) {\n        path.traverse({\n          CallExpression: {\n            exit(path) {\n              if (!path.get(\"callee\").isSuper()) return;\n              path.replaceWith(_core.types.callExpression(_core.types.cloneNode(protoInitLocal), [path.node]));\n              path.skip();\n            }\n\n          }\n        });\n      } else {\n        constructorPath.node.body.body.unshift(_core.types.expressionStatement(protoInitCall));\n      }\n    } else {\n      const body = [_core.types.expressionStatement(protoInitCall)];\n\n      if (path.node.superClass) {\n        body.unshift(_core.types.expressionStatement(_core.types.callExpression(_core.types.super(), [_core.types.spreadElement(_core.types.identifier(\"args\"))])));\n      }\n\n      path.node.body.body.unshift(_core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [_core.types.restElement(_core.types.identifier(\"args\"))], _core.types.blockStatement(body)));\n    }\n  }\n\n  if (requiresStaticInit) {\n    staticInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initStatic\");\n    locals.push(staticInitLocal);\n  }\n\n  if (decoratedPrivateMethods.size > 0) {\n    path.traverse({\n      PrivateName(path) {\n        if (!decoratedPrivateMethods.has(path.node.id.name)) return;\n        const parentPath = path.parentPath;\n        const parentParentPath = parentPath.parentPath;\n\n        if (parentParentPath.node.type === \"AssignmentExpression\" && parentParentPath.node.left === parentPath.node || parentParentPath.node.type === \"UpdateExpression\" || parentParentPath.node.type === \"RestElement\" || parentParentPath.node.type === \"ArrayPattern\" || parentParentPath.node.type === \"ObjectProperty\" && parentParentPath.node.value === parentPath.node && parentParentPath.parentPath.type === \"ObjectPattern\" || parentParentPath.node.type === \"ForOfStatement\" && parentParentPath.node.left === parentPath.node) {\n          throw path.buildCodeFrameError(`Decorated private methods are not updatable, but \"#${path.node.id.name}\" is updated via this expression.`);\n        }\n      }\n\n    });\n  }\n\n  let classInitInjected = false;\n\n  const classInitCall = classInitLocal && _core.types.callExpression(_core.types.cloneNode(classInitLocal), []);\n\n  const originalClass = path.node;\n\n  if (classDecorators) {\n    locals.push(classLocal, classInitLocal);\n    const statics = [];\n    let staticBlocks = [];\n    path.get(\"body.body\").forEach(element => {\n      if (element.isStaticBlock()) {\n        staticBlocks.push(element.node);\n        element.remove();\n        return;\n      }\n\n      const isProperty = element.isClassProperty() || element.isClassPrivateProperty();\n\n      if ((isProperty || element.isClassPrivateMethod()) && element.node.static) {\n        if (isProperty && staticBlocks.length > 0) {\n          const allValues = staticBlocks.map(staticBlockToIIFE);\n          if (element.node.value) allValues.push(element.node.value);\n          element.node.value = maybeSequenceExpression(allValues);\n          staticBlocks = [];\n        }\n\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      }\n    });\n\n    if (statics.length > 0 || staticBlocks.length > 0) {\n      const staticsClass = _core.template.expression.ast`\n        class extends ${state.addHelper(\"identity\")} {}\n      `;\n      staticsClass.body.body = [_core.types.staticBlock([_core.types.toStatement(path.node, false)]), ...statics];\n      const constructorBody = [];\n\n      const newExpr = _core.types.newExpression(staticsClass, []);\n\n      if (staticBlocks.length > 0) {\n        constructorBody.push(...staticBlocks.map(staticBlockToIIFE));\n      }\n\n      if (classInitCall) {\n        classInitInjected = true;\n        constructorBody.push(classInitCall);\n      }\n\n      if (constructorBody.length > 0) {\n        constructorBody.unshift(_core.types.callExpression(_core.types.super(), [_core.types.cloneNode(classLocal)]));\n        staticsClass.body.body.push(_core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [], _core.types.blockStatement([_core.types.expressionStatement(_core.types.sequenceExpression(constructorBody))])));\n      } else {\n        newExpr.arguments.push(_core.types.cloneNode(classLocal));\n      }\n\n      path.replaceWith(newExpr);\n    }\n  }\n\n  if (!classInitInjected && classInitCall) {\n    path.node.body.body.push(_core.types.staticBlock([_core.types.expressionStatement(classInitCall)]));\n  }\n\n  originalClass.body.body.unshift(_core.types.staticBlock([_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.arrayPattern(locals), _core.types.callExpression(state.addHelper(\"applyDecs\"), [_core.types.thisExpression(), elementDecorations, classDecorations]))), requiresStaticInit && _core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(staticInitLocal), [_core.types.thisExpression()]))].filter(Boolean)));\n  path.insertBefore(assignments.map(expr => _core.types.expressionStatement(expr)));\n  path.scope.crawl();\n  return path;\n}\n\nfunction _default({\n  assertVersion,\n  assumption\n}, {\n  loose\n}) {\n  var _assumption;\n\n  assertVersion(\"^7.16.0\");\n  const VISITED = new WeakSet();\n  const constantSuper = (_assumption = assumption(\"constantSuper\")) != null ? _assumption : loose;\n  return {\n    name: \"proposal-decorators\",\n    inherits: _pluginSyntaxDecorators.default,\n    visitor: {\n      \"ExportNamedDeclaration|ExportDefaultDeclaration\"(path) {\n        var _declaration$decorato;\n\n        const {\n          declaration\n        } = path.node;\n\n        if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0) {\n          (0, _helperSplitExportDeclaration.default)(path);\n        }\n      },\n\n      Class(path, state) {\n        if (VISITED.has(path)) return;\n        const newPath = transformClass(path, state, constantSuper);\n        if (newPath) VISITED.add(newPath);\n      }\n\n    }\n  };\n}"]}